<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Enhanced City Size Comparison Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            touch-action: pan-x pan-y;
            position: relative;
        }

        /* Subtle operational dashboard link */
        .ops-dashboard-link {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 10px !important;
            height: 10px !important;
            min-width: 10px !important;
            min-height: 10px !important;
            max-width: 10px !important;
            max-height: 10px !important;
            background: #666;
            border-radius: 2px;
            cursor: pointer;
            opacity: 0.3;
            transition: all 0.2s ease;
            z-index: 1000;
            border: none !important;
            padding: 0 !important;
            margin: 0 !important;
            font-size: 0;
            line-height: 0;
        }

        .ops-dashboard-link:hover {
            opacity: 0.8;
            background: #007AFF;
            transform: scale(1.2);
        }

        .ops-dashboard-link:active {
            transform: scale(1.1);
        }
        
        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        label {
            font-weight: 600;
            min-width: 120px;
        }
        
        select, button {
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            min-height: 44px;
            min-width: 44px;
        }
        
        button {
            background: #007AFF;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        button:hover {
            background: #0056CC;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        #map {
            height: 600px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        /* World Map City Selection Styles */
        .world-map-section {
            margin: 20px 0;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .world-map-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.2em;
        }

        .map-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 15px;
        }

        .selection-status {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .continent-nav {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .continent-pill {
            padding: 6px 12px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 16px;
            font-size: 0.85em;
            font-weight: 500;
            color: #495057;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }

        .continent-pill:hover {
            background: #e3f2fd;
            border-color: #90caf9;
            color: #1976d2;
            transform: translateY(-1px);
        }

        .continent-pill.active {
            background: #1976d2;
            border-color: #1565c0;
            color: white;
        }

        .continent-pill.active:hover {
            background: #1565c0;
            border-color: #0d47a1;
        }

        .swap-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            color: #666;
        }

        .swap-button:hover {
            background: #e3f2fd;
            border-color: #1976d2;
            color: #1976d2;
            transform: scale(1.1);
        }

        .swap-button:active {
            transform: scale(0.95);
        }

        .swap-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .swap-button:disabled:hover {
            background: #f5f5f5;
            border-color: #ddd;
            color: #666;
            transform: none;
        }

        .selection-step {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f5f5f5;
            border-radius: 20px;
            border: 2px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
        }

        .selection-step:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .selection-step.active {
            background: #e3f2fd;
            border-color: #1976d2;
        }

        .selection-step.completed {
            background: #e8f5e8;
            border-color: #4caf50;
        }

        .selection-step.base-completed {
            background: #e8f5e8;
            border-color: #4caf50;
        }

        .selection-step.overlay-completed {
            background: #fff3e0;
            border-color: #ff9800;
        }

        .step-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #999;
            color: white;
            border-radius: 50%;
            font-size: 0.8em;
            font-weight: bold;
        }

        .selection-step.active .step-number {
            background: #1976d2;
        }

        .selection-step.completed .step-number,
        .selection-step.base-completed .step-number {
            background: #4caf50;
        }

        .selection-step.overlay-completed .step-number {
            background: #ff9800;
        }

        .step-text {
            font-weight: 500;
        }

        #worldMap {
            height: 400px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        /* City pin styles */
        .city-pin {
            background: #1976d2;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.2s;
        }

        .city-pin:hover {
            background: #1565c0;
            transform: scale(1.2);
        }

        /* Cities without detailed boundaries - hollow blue outline */
        .city-pin.no-detailed-boundary {
            background: white;
            border: 2px solid #1976d2;
        }

        .city-pin.no-detailed-boundary:hover {
            background: #e3f2fd;
            border-color: #1565c0;
            transform: scale(1.2);
        }

        .city-pin.base-selected {
            background: #4caf50;
            border-color: #2e7d32;
        }

        .city-pin.overlay-selected {
            background: #ff9800;
            border-color: #f57c00;
        }

        .city-pin.both-selected {
            background: linear-gradient(45deg, #4caf50 50%, #ff9800 50%);
            border-color: #333;
        }

        /* Selection states for cities without detailed boundaries */
        .city-pin.no-detailed-boundary.base-selected {
            background: #e8f5e8;
            border: 2px solid #4caf50;
        }

        .city-pin.no-detailed-boundary.overlay-selected {
            background: #fff3e0;
            border: 2px solid #ff9800;
        }

        .city-pin.no-detailed-boundary.both-selected {
            background: linear-gradient(45deg, #e8f5e8 50%, #fff3e0 50%);
            border: 2px solid #333;
        }
        
        .info-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        .comparison-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007AFF;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007AFF;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Transformation controls styling */
        #transformControls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            display: none;
        }
        
        /* Collapsible controls for mobile */
        .collapsible-header {
            display: none;
            padding: 12px 16px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px;
            margin-bottom: 10px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            text-align: left;
            font-size: 16px;
        }
        
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .collapsible-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .collapsible-content.collapsed {
                max-height: 0;
                padding-top: 0;
                padding-bottom: 0;
                margin-top: 0;
                border-top: none;
            }
            
            .collapsible-content.expanded {
                max-height: 1000px;
            }
            
            .controls {
                padding: 15px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .control-group label {
                min-width: auto;
                margin-bottom: 5px;
            }
        }

        #transformControls h4 {
            margin: 0 0 15px 0;
            color: #333;
        }

        #transformControls input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
        
        /* Enhanced Visual Feedback */
        .transformation-preview {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            font-size: 14px;
            min-width: 200px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }
        
        .transformation-preview.active {
            opacity: 1;
            transform: translateX(0);
        }
        
        .transform-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .transform-stat:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .transform-label {
            font-weight: 600;
            color: #333;
        }
        
        .transform-value {
            color: #007AFF;
            font-weight: 500;
        }
        
        /* Boundary highlight effects */
        .boundary-highlight {
            animation: boundaryPulse 2s ease-in-out infinite;
        }
        
        @keyframes boundaryPulse {
            0%, 100% { 
                stroke-width: 2;
                stroke-opacity: 0.8;
            }
            50% { 
                stroke-width: 4;
                stroke-opacity: 1;
            }
        }
        
        /* Snap guides */
        .snap-guide {
            stroke: #FF9500;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            opacity: 0.7;
            animation: snapGuideFlash 0.5s ease-in-out;
        }
        
        @keyframes snapGuideFlash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        /* Input Methods Help Panel */
        .input-help-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .help-toggle {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #007AFF;
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }
        
        .help-toggle:hover {
            background: #0056CC;
            transform: scale(1.05);
        }
        
        .help-content {
            position: absolute;
            bottom: 50px;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 250px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .help-content.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        .help-content h4 {
            margin: 0 0 12px 0;
            color: #333;
            font-size: 16px;
        }
        
        .help-section {
            margin-bottom: 12px;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .help-section:last-child {
            margin-bottom: 0;
        }
        
        .help-section strong {
            color: #007AFF;
        }
        
        @media (max-width: 768px) {
            .input-help-panel {
                bottom: 80px;
                right: 15px;
            }
            
            .help-content {
                right: -100px;
                min-width: 200px;
            }
        }

        #transformControls button {
            min-width: 40px;
            height: 40px;
            font-size: 16px;
        }

        .move-grid {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            gap: 5px;
            justify-content: start;
        }
    </style>
</head>
<body>
    <!-- Subtle operational dashboard access -->
    <button class="ops-dashboard-link" onclick="location.href='operational-dashboard.html'" title="Operations Dashboard"></button>
    
    <div class="container">
        <h1>üó∫Ô∏è Enhanced City Size Comparison Tool</h1>
        <p style="text-align: center; color: #666; margin-bottom: 30px;">
            Compare actual city boundaries with rotation and translation controls
        </p>
        
        <!-- Hidden elements for backend functionality -->
        <select id="baseCity" style="display: none;">
            <option value="">Loading cities...</option>
        </select>
        <select id="overlayCity" style="display: none;">
            <option value="">Loading cities...</option>
        </select>
        <button id="compareBtn" style="display: none;">Compare Cities</button>
        <button id="swapBtn" style="display: none;">Swap Cities</button>
        
        <!-- World Map City Selection -->
        <div class="world-map-section">
            <h3>Select Cities by Clicking on the Map</h3>
            <div class="map-controls">
                <div class="selection-status">
                    <div class="selection-step">
                        <span class="step-number">1</span>
                        <span class="step-text" id="baseStatus">Select base city</span>
                    </div>
                    <button class="swap-button" id="swapCitiesBtn" title="Swap base and overlay cities">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M17 17l4-4-4-4"/>
                            <path d="M7 7l-4 4 4 4"/>
                            <path d="M21 13H3"/>
                            <path d="M3 11h18"/>
                        </svg>
                    </button>
                    <div class="selection-step">
                        <span class="step-number">2</span>
                        <span class="step-text" id="overlayStatus">Select overlay city</span>
                    </div>
                </div>
                <div class="continent-nav">
                    <div class="continent-pill" data-continent="north-america">North America</div>
                    <div class="continent-pill" data-continent="south-america">South America</div>
                    <div class="continent-pill" data-continent="europe">Europe</div>
                    <div class="continent-pill" data-continent="asia">Asia</div>
                    <div class="continent-pill" data-continent="africa">Africa</div>
                    <div class="continent-pill" data-continent="oceania">Oceania</div>
                </div>
            </div>
            <div id="worldMap"></div>
        </div>
        
        <div id="map"></div>
        
        <!-- Enhanced Visual Feedback Panel -->
        <div class="transformation-preview" id="transformationPreview">
            <div class="transform-stat">
                <span class="transform-label">Rotation:</span>
                <span class="transform-value" id="previewRotation">0¬∞</span>
            </div>
            <div class="transform-stat">
                <span class="transform-label">Position:</span>
                <span class="transform-value" id="previewPosition">Center</span>
            </div>
            <div class="transform-stat">
                <span class="transform-label">Status:</span>
                <span class="transform-value" id="previewStatus">Ready</span>
            </div>
        </div>
        
        <!-- Input Methods Help Panel -->
        <div class="input-help-panel" id="inputHelpPanel">
            <button class="help-toggle" onclick="toggleInputHelp()">?</button>
            <div class="help-content" id="helpContent">
                <h4>Input Methods</h4>
                <div class="help-section">
                    <strong>Touch (Mobile):</strong><br>
                    ‚Ä¢ Two fingers: Rotate overlay<br>
                    ‚Ä¢ Double-tap: Reset transformations
                </div>
                <div class="help-section">
                    <strong>Trackpad/Mouse:</strong><br>
                    ‚Ä¢ Shift + Scroll: Rotate overlay<br>
                    ‚Ä¢ Cmd + Scroll: Rotate overlay (Mac)<br>
                    ‚Ä¢ Click + Drag: Move overlay position<br>
                    ‚Ä¢ <em>Map zoom disabled for gestures</em>
                </div>
                <div class="help-section">
                    <strong>Keyboard:</strong><br>
                    ‚Ä¢ Arrow keys: Move overlay<br>
                    ‚Ä¢ Cmd/Ctrl + Arrows: Rotate<br>
                    ‚Ä¢ R or Escape: Reset all
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div id="status" class="loading">Select two cities to begin comparison...</div>
            <div id="comparison-results"></div>
            
            <!-- Advanced Scaling Section -->
            <div id="advanced-scaling" class="controls" style="display: none;">
                <div class="collapsible-header" onclick="toggleScalingOptions()" style="background: #f8f9fa; padding: 15px; cursor: pointer; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                    <span style="font-weight: 600; color: #495057;">‚ö° Explore Density Scaling</span>
                    <span id="scaling-toggle" style="color: #6c757d;">‚ñº</span>
                </div>
                
                <div id="scaling-options" class="scaling-content" style="display: none; padding-top: 20px;">
                    <!-- Scaling Toggle -->
                    <div class="control-group" style="margin-bottom: 20px;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600;">Density Scaling:</label>
                        <div class="scaling-toggle" style="display: flex; gap: 15px;">
                            <button id="scaling-off" class="toggle-pill active" onclick="toggleScaling('off')" 
                                    style="padding: 8px 16px; border: 2px solid #dee2e6; border-radius: 20px; background: #f8f9fa; color: #495057; font-size: 14px; cursor: pointer; transition: all 0.2s;">
                                Off
                            </button>
                            <button id="scaling-on" class="toggle-pill" onclick="toggleScaling('on')" 
                                    style="padding: 8px 16px; border: 2px solid #dee2e6; border-radius: 20px; background: white; color: #495057; font-size: 14px; cursor: pointer; transition: all 0.2s;">
                                On
                            </button>
                        </div>
                    </div>
                    
                    <!-- Scaling Metric Pills -->
                    <div id="scaling-metrics-section" class="control-group" style="display: none;">
                        <label style="display: block; margin-bottom: 10px; font-weight: 600;">Scale by:</label>
                        <div class="scaling-pills" style="display: flex; flex-wrap: wrap; gap: 8px;">
                            <button class="metric-pill" data-metric="population_density" onclick="selectScalingMetric('population_density')" 
                                    style="padding: 10px 15px; border: 2px solid #dee2e6; border-radius: 20px; background: white; color: #495057; font-size: 13px; cursor: pointer; transition: all 0.2s;">
                                Population Density
                            </button>
                            <button class="metric-pill" data-metric="economic_density" onclick="selectScalingMetric('economic_density')" 
                                    style="padding: 10px 15px; border: 2px solid #dee2e6; border-radius: 20px; background: white; color: #495057; font-size: 13px; cursor: pointer; transition: all 0.2s;">
                                Economic Density
                            </button>
                            <button class="metric-pill" data-metric="cultural_density" onclick="selectScalingMetric('cultural_density')" 
                                    style="padding: 10px 15px; border: 2px solid #dee2e6; border-radius: 20px; background: white; color: #495057; font-size: 13px; cursor: pointer; transition: all 0.2s;">
                                Cultural Density
                            </button>
                            <button class="metric-pill" data-metric="transit_density" onclick="selectScalingMetric('transit_density')" 
                                    style="padding: 10px 15px; border: 2px solid #dee2e6; border-radius: 20px; background: white; color: #495057; font-size: 13px; cursor: pointer; transition: all 0.2s;">
                                Transit Density
                            </button>
                        </div>
                    </div>
                    
                    <div id="scaling-preview" style="background: #e3f2fd; padding: 15px; border-radius: 6px; margin: 15px 0; display: none;">
                        <div style="font-style: italic; color: #1565c0;" id="scaling-explanation"></div>
                        <div style="margin-top: 8px; font-size: 14px; color: #666;" id="scaling-details"></div>
                    </div>
                    
                    <div id="scaling-actions" class="control-group" style="display: none;">
                        <div style="text-align: center; padding: 15px; background: #f8f9fa; border-radius: 6px; color: #6c757d; font-size: 14px;">
                            Scaling will apply automatically when you select a metric
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // City data helper function (replaced with database-driven approach)
        function getCityData(cityId) {
            if (!citiesDatabase) return null;
            const city = citiesDatabase.cities.find(c => c.id === cityId);
            if (!city) return null;
            
            return {
                name: city.name,
                center: city.coordinates,
                color: city.id === selectedBaseCity?.id ? '#4ECDC4' : '#FF6B6B',
                boundaryFile: city.boundaryFile
            };
        }

        // Initialize map with gesture controls and zoom buttons
        const map = L.map('map', {
            touchZoom: false,
            doubleClickZoom: false,
            scrollWheelZoom: false,
            boxZoom: false,
            keyboard: false,
            zoomControl: true // Enable zoom buttons for main comparison map
        }).setView([40.7128, -74.0060], 10);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19,
            attribution: '¬© OpenStreetMap contributors, ¬© CARTO'
        }).addTo(map);

        // Add scale control (distance ruler) to show map scale
        L.control.scale({
            position: 'bottomleft',
            maxWidth: 200,
            metric: true,
            imperial: true,
            updateWhenIdle: false
        }).addTo(map);

        // Layer groups for cities
        const baseLayer = L.layerGroup().addTo(map);
        const overlayLayer = L.layerGroup().addTo(map);

        // Initialize world map for city selection
        const worldMap = L.map('worldMap', {
            zoomControl: true // Enable zoom controls for world map
        }).setView([20, 0], 2);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 10,
            attribution: '¬© OpenStreetMap contributors, ¬© CARTO'
        }).addTo(worldMap);

        // World map city selection state
        let selectedBaseCity = null;
        let selectedOverlayCity = null;
        let selectionStep = 'base'; // 'base' or 'overlay'
        const cityPins = {};
        let citiesDatabase = null;
        let selectedContinent = null;

        // Continent coordinates and zoom levels for world map navigation
        const continentViews = {
            'north-america': { center: [45, -100], zoom: 3 },
            'south-america': { center: [-15, -60], zoom: 3 },
            'europe': { center: [54, 15], zoom: 4 },
            'asia': { center: [30, 100], zoom: 3 },
            'africa': { center: [0, 20], zoom: 3 },
            'oceania': { center: [-25, 140], zoom: 4 }
        };

        // UI elements
        const baseCitySelect = document.getElementById('baseCity');
        const overlayCitySelect = document.getElementById('overlayCity');
        const compareBtn = document.getElementById('compareBtn');
        const swapBtn = document.getElementById('swapBtn');
        const status = document.getElementById('status');
        const results = document.getElementById('comparison-results');

        // World map city loading and selection functions
        async function loadCitiesDatabase() {
            try {
                const response = await fetch('./cities-database.json');
                citiesDatabase = await response.json();
                createCityPins();
                populateDropdowns();
                console.log(`Loaded ${citiesDatabase.cities.length} cities`);
            } catch (error) {
                console.error('Failed to load cities database:', error);
                status.innerHTML = '<div class="error">Failed to load cities database</div>';
            }
        }

        function populateDropdowns() {
            // Clear existing options (except the first placeholder)
            baseCitySelect.innerHTML = '<option value="">Select base city...</option>';
            overlayCitySelect.innerHTML = '<option value="">Select overlay city...</option>';

            // Add all cities to both dropdowns
            citiesDatabase.cities.forEach(city => {
                const baseOption = document.createElement('option');
                baseOption.value = city.id;
                baseOption.textContent = `${city.name}, ${city.country}`;
                baseCitySelect.appendChild(baseOption);

                const overlayOption = document.createElement('option');
                overlayOption.value = city.id;
                overlayOption.textContent = `${city.name}, ${city.country}`;
                overlayCitySelect.appendChild(overlayOption);
            });
        }

        function createCityPins() {
            citiesDatabase.cities.forEach(city => {
                const [lat, lng] = city.coordinates;
                
                // Determine pin class based on whether city has detailed boundary
                const hasDetailedBoundary = city.hasDetailedBoundary;
                const pinClass = hasDetailedBoundary ? 'city-pin' : 'city-pin no-detailed-boundary';
                
                const pinIcon = L.divIcon({
                    className: pinClass,
                    html: '',
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                });

                const marker = L.marker([lat, lng], { 
                    icon: pinIcon,
                    title: `${city.name}, ${city.country}${hasDetailedBoundary ? '' : ' (basic boundary)'}`
                }).addTo(worldMap);

                marker.on('click', () => selectCity(city));
                cityPins[city.id] = marker;
            });
        }

        function selectCity(city) {
            // Check for deselection
            if (selectedBaseCity && city.id === selectedBaseCity.id) {
                // Deselect base city
                deselectBaseCity();
                return;
            }
            
            if (selectedOverlayCity && city.id === selectedOverlayCity.id) {
                // Deselect overlay city
                deselectOverlayCity();
                return;
            }

            if (selectionStep === 'base') {
                // Select as base city
                selectedBaseCity = city;
                baseCitySelect.value = city.id;
                updatePinStyles();
                updateSelectionStatus();
                updateMapView(); // Zoom to base city
                selectionStep = 'overlay';
            } else if (selectionStep === 'overlay') {
                // Select as overlay city
                if (city.id === selectedBaseCity?.id) {
                    // Same city selected, ignore
                    return;
                }
                selectedOverlayCity = city;
                overlayCitySelect.value = city.id;
                updatePinStyles();
                updateSelectionStatus();
                
                // Auto-trigger comparison
                updateButtons();
                if (compareBtn.disabled === false) {
                    compareCities();
                }
            }
        }

        function deselectBaseCity() {
            selectedBaseCity = null;
            baseCitySelect.value = '';
            selectionStep = 'base';
            updatePinStyles();
            updateSelectionStatus();
            updateMapView(); // Zoom back to world view
            
            // Clear comparison if both were selected
            if (selectedOverlayCity) {
                clearComparison();
            }
        }

        function deselectOverlayCity() {
            selectedOverlayCity = null;
            overlayCitySelect.value = '';
            selectionStep = 'overlay';
            updatePinStyles();
            updateSelectionStatus();
            
            // Clear comparison
            clearComparison();
        }

        function clearComparison() {
            // Clear the maps
            baseLayer.clearLayers();
            overlayLayer.clearLayers();
            
            // Clear results
            const results = document.getElementById('comparison-results');
            if (results) {
                results.innerHTML = '';
            }
            
            // Don't reset map view here - let updateMapView() handle it based on base city selection
        }

        function swapCities() {
            if (!selectedBaseCity || !selectedOverlayCity) {
                return; // Can't swap if both cities aren't selected
            }

            // Swap the cities
            const tempCity = selectedBaseCity;
            selectedBaseCity = selectedOverlayCity;
            selectedOverlayCity = tempCity;

            // Update the hidden selects
            baseCitySelect.value = selectedBaseCity.id;
            overlayCitySelect.value = selectedOverlayCity.id;

            // Update visual states
            updatePinStyles();
            updateSelectionStatus();
            updateSwapButtonState();
            updateMapView(); // Zoom to new base city

            // Re-trigger comparison with swapped cities
            updateButtons();
            if (compareBtn.disabled === false) {
                compareCities();
            }
        }

        function updateSwapButtonState() {
            const swapBtn = document.getElementById('swapCitiesBtn');
            if (selectedBaseCity && selectedOverlayCity) {
                swapBtn.disabled = false;
            } else {
                swapBtn.disabled = true;
            }
        }

        function updateMapView() {
            if (selectedBaseCity) {
                // Zoom to base city
                const [lat, lng] = selectedBaseCity.coordinates;
                map.setView([lat, lng], 11, { animate: true, duration: 0.8 });
            } else {
                // Zoom back to world view
                map.setView([40.7128, -74.0060], 3, { animate: true, duration: 0.8 });
            }
        }

        function updatePinStyles() {
            // Reset all pins by removing selection classes
            Object.values(cityPins).forEach(pin => {
                const element = pin.getElement();
                element.classList.remove('base-selected', 'overlay-selected', 'both-selected');
            });

            // Style selected pins
            if (selectedBaseCity && cityPins[selectedBaseCity.id]) {
                const basePin = cityPins[selectedBaseCity.id].getElement();
                if (selectedOverlayCity && selectedBaseCity.id === selectedOverlayCity.id) {
                    basePin.classList.add('both-selected');
                } else {
                    basePin.classList.add('base-selected');
                }
            }

            if (selectedOverlayCity && selectedOverlayCity.id !== selectedBaseCity?.id && cityPins[selectedOverlayCity.id]) {
                cityPins[selectedOverlayCity.id].getElement().classList.add('overlay-selected');
            }
        }

        function updateSelectionStatus() {
            const baseStatus = document.getElementById('baseStatus');
            const overlayStatus = document.getElementById('overlayStatus');
            const baseStep = baseStatus.parentElement;
            const overlayStep = overlayStatus.parentElement;

            // Reset all step classes
            baseStep.classList.remove('completed', 'base-completed', 'overlay-completed', 'active');
            overlayStep.classList.remove('completed', 'base-completed', 'overlay-completed', 'active');

            // Update base city status
            if (selectedBaseCity) {
                baseStatus.textContent = `${selectedBaseCity.name}, ${selectedBaseCity.country}`;
                baseStep.classList.add('base-completed');
            } else {
                baseStatus.textContent = 'Select base city';
                baseStep.classList.add('active');
            }

            // Update overlay city status
            if (selectedOverlayCity) {
                overlayStatus.textContent = `${selectedOverlayCity.name}, ${selectedOverlayCity.country}`;
                overlayStep.classList.add('overlay-completed');
            } else {
                overlayStatus.textContent = 'Select overlay city';
                if (selectedBaseCity) {
                    overlayStep.classList.add('active');
                }
            }

            // Update swap button state
            updateSwapButtonState();
        }

        // Initialize the world map when page loads
        loadCitiesDatabase();

        // Add click handlers for selection pills and swap button
        document.addEventListener('DOMContentLoaded', function() {
            const baseStep = document.querySelector('#baseStatus').parentElement;
            const overlayStep = document.querySelector('#overlayStatus').parentElement;
            const swapButton = document.querySelector('#swapCitiesBtn');

            baseStep.addEventListener('click', function() {
                if (selectedBaseCity) {
                    deselectBaseCity();
                }
            });

            overlayStep.addEventListener('click', function() {
                if (selectedOverlayCity) {
                    deselectOverlayCity();
                }
            });

            swapButton.addEventListener('click', function() {
                swapCities();
            });

            // Initialize swap button state
            updateSwapButtonState();
        });

        // Transformation controls (gesture-only)

        // Transformation state
        let currentBase = null;
        let currentOverlay = null;
        let baseBoundaryData = null;
        let overlayBoundaryData = null;
        let originalOverlayData = null;
        let overlayRotation = 0;
        let overlayTranslation = { lat: 0, lng: 0 };

        // Event listeners
        baseCitySelect.addEventListener('change', updateButtons);
        overlayCitySelect.addEventListener('change', updateButtons);
        compareBtn.addEventListener('click', compareCities);
        swapBtn.addEventListener('click', swapCities);
        
        // Continent navigation event handlers
        document.querySelectorAll('.continent-pill').forEach(pill => {
            pill.addEventListener('click', function() {
                const continent = this.getAttribute('data-continent');
                
                // Check if this continent is already selected
                if (selectedContinent === continent) {
                    // Deselect continent - zoom back to world view
                    selectedContinent = null;
                    this.classList.remove('active');
                    worldMap.setView([40.7128, -74.0060], 3, { animate: true, duration: 0.8 });
                } else {
                    // Clear previous selection
                    document.querySelectorAll('.continent-pill').forEach(p => p.classList.remove('active'));
                    
                    // Select new continent
                    selectedContinent = continent;
                    this.classList.add('active');
                    
                    // Zoom to continent
                    const view = continentViews[continent];
                    worldMap.setView(view.center, view.zoom, { animate: true, duration: 0.8 });
                }
            });
        });


        function updateButtons() {
            const hasBase = baseCitySelect.value;
            const hasOverlay = overlayCitySelect.value;
            const different = hasBase !== hasOverlay;
            
            compareBtn.disabled = !(hasBase && hasOverlay && different);
            swapBtn.disabled = !(hasBase && hasOverlay);
        }

        // Transformation functions (gesture-controlled)
        function resetRotation() {
            overlayRotation = 0;
            updateOverlayDisplay();
        }

        function resetPosition() {
            overlayTranslation = { lat: 0, lng: 0 };
            updateOverlayDisplay();
        }

        function updateOverlayDisplay() {
            if (!originalOverlayData || !baseBoundaryData) return;
            
            // Clear existing overlay
            overlayLayer.clearLayers();
            
            const baseCity = getCityData(currentBase);
            const overlayCity = getCityData(currentOverlay);
            
            // Transform overlay with current rotation and translation
            const transformedOverlay = transformGeoJSON(
                originalOverlayData, 
                baseCity.center, 
                1, 
                overlayRotation, 
                overlayTranslation
            );
            
            // Add transformed overlay to map with enhanced styling
            const overlayGeoJsonLayer = L.geoJSON(transformedOverlay, {
                style: {
                    color: overlayCity.color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: overlayCity.color,
                    fillOpacity: 0.3,
                    dashArray: '10, 5'
                }
            });
            overlayLayer.addLayer(overlayGeoJsonLayer);
            
            // Update transformation preview
            updateTransformationPreview();
            
            // Add smooth transition effect
            const overlayElement = overlayGeoJsonLayer.getElement?.();
            if (overlayElement) {
                overlayElement.style.transition = 'all 0.2s ease-out';
            }
        }
        
        function updateTransformationPreview() {
            const preview = document.getElementById('transformationPreview');
            const rotationElement = document.getElementById('previewRotation');
            const positionElement = document.getElementById('previewPosition');
            const statusElement = document.getElementById('previewStatus');
            
            if (currentOverlay && currentBase) {
                preview.classList.add('active');
                rotationElement.textContent = `${overlayRotation}¬∞`;
                
                // Calculate position description
                const totalOffset = Math.sqrt(overlayTranslation.lat ** 2 + overlayTranslation.lng ** 2);
                if (totalOffset < 0.05) {
                    positionElement.textContent = 'Center';
                } else {
                    positionElement.textContent = `Offset ${totalOffset.toFixed(2)}¬∞`;
                }
                
                // Update status based on transformation
                if (overlayRotation === 0 && totalOffset < 0.05) {
                    statusElement.textContent = 'Original';
                } else {
                    statusElement.textContent = 'Transformed';
                }
            } else {
                preview.classList.remove('active');
            }
        }
        
        function highlightBoundary(layer, highlight = true) {
            if (!layer) return;
            
            const element = layer.getElement?.();
            if (element) {
                if (highlight) {
                    element.classList.add('boundary-highlight');
                } else {
                    element.classList.remove('boundary-highlight');
                }
            }
        }
        
        function showSnapGuide(rotation) {
            // Show snap guides at common angles (0¬∞, 45¬∞, 90¬∞, etc.)
            const snapAngles = [0, 45, 90, 135, 180, 225, 270, 315];
            const snapThreshold = 5; // degrees
            
            for (const snapAngle of snapAngles) {
                const diff = Math.abs(((rotation - snapAngle + 180) % 360) - 180);
                if (diff < snapThreshold) {
                    showGestureIndicator(`üìê Snap to ${snapAngle}¬∞`);
                    return snapAngle;
                }
            }
            return rotation;
        }

        async function loadCityBoundary(cityKey) {
            const city = getCityData(cityKey);
            if (!city) {
                throw new Error(`Unknown city: ${cityKey}`);
            }
            
            try {
                const response = await fetch(city.boundaryFile);
                if (!response.ok) {
                    throw new Error(`Failed to load ${city.name} boundary data`);
                }
                
                const geojson = await response.json();
                return geojson;
            } catch (error) {
                console.error(`Error loading boundary for ${city.name}:`, error);
                throw error;
            }
        }

        function calculateGeoJSONArea(geojson) {
            // Calculate approximate area from GeoJSON coordinates
            let totalArea = 0;
            
            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    totalArea += calculateFeatureArea(feature);
                });
            } else if (geojson.type === 'Feature') {
                totalArea = calculateFeatureArea(geojson);
            }
            
            return totalArea;
        }

        function calculateFeatureArea(feature) {
            const geometry = feature.geometry;
            let area = 0;
            
            if (geometry.type === 'Polygon') {
                area = calculatePolygonArea(geometry.coordinates[0]);
            } else if (geometry.type === 'MultiPolygon') {
                geometry.coordinates.forEach(polygon => {
                    area += calculatePolygonArea(polygon[0]);
                });
            }
            
            return area;
        }

        function calculatePolygonArea(coordinates) {
            // Simple area calculation (not geodesically accurate, but good for comparison)
            if (!coordinates || coordinates.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < coordinates.length - 1; i++) {
                area += (coordinates[i][0] * coordinates[i + 1][1] - coordinates[i + 1][0] * coordinates[i][1]);
            }
            
            return Math.abs(area) / 2;
        }

        function transformGeoJSON(geojson, newCenter, scaleFactor = 1, rotation = 0, translation = { lat: 0, lng: 0 }) {
            // Calculate current centroid using a simpler approach
            let totalLat = 0, totalLon = 0, pointCount = 0;
            
            function extractPoints(coords) {
                if (typeof coords[0] === 'number') {
                    totalLon += coords[0];
                    totalLat += coords[1];
                    pointCount++;
                } else {
                    coords.forEach(extractPoints);
                }
            }
            
            // Extract all points to find centroid
            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    extractPoints(feature.geometry.coordinates);
                });
            } else if (geojson.type === 'Feature') {
                extractPoints(geojson.geometry.coordinates);
            }
            
            const currentCenter = [totalLon / pointCount, totalLat / pointCount];
            
            // Convert rotation to radians (negate for intuitive clockwise positive rotation)
            const rotationRad = (-rotation * Math.PI) / 180;
            const cos = Math.cos(rotationRad);
            const sin = Math.sin(rotationRad);
            
            // Deep clone and transform coordinates
            const transformedGeoJSON = JSON.parse(JSON.stringify(geojson));
            
            function transformCoordinates(coords) {
                if (typeof coords[0] === 'number') {
                    // This is a coordinate pair [lon, lat]
                    let deltaLon = (coords[0] - currentCenter[0]) * scaleFactor;
                    let deltaLat = (coords[1] - currentCenter[1]) * scaleFactor;
                    
                    // Apply rotation
                    if (rotation !== 0) {
                        const rotatedLon = deltaLon * cos - deltaLat * sin;
                        const rotatedLat = deltaLon * sin + deltaLat * cos;
                        deltaLon = rotatedLon;
                        deltaLat = rotatedLat;
                    }
                    
                    // Apply translation and position at new center
                    return [
                        newCenter[1] + deltaLon + translation.lng, 
                        newCenter[0] + deltaLat + translation.lat
                    ];
                } else {
                    // This is an array of coordinates
                    return coords.map(transformCoordinates);
                }
            }

            if (transformedGeoJSON.type === 'FeatureCollection') {
                transformedGeoJSON.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (transformedGeoJSON.type === 'Feature') {
                if (transformedGeoJSON.geometry && transformedGeoJSON.geometry.coordinates) {
                    transformedGeoJSON.geometry.coordinates = transformCoordinates(transformedGeoJSON.geometry.coordinates);
                }
            }

            return transformedGeoJSON;
        }

        async function compareCities() {
            const baseKey = baseCitySelect.value;
            const overlayKey = overlayCitySelect.value;
            
            if (!baseKey || !overlayKey || baseKey === overlayKey) return;
            
            status.innerHTML = '<div class="spinner"></div>Loading high-resolution city boundaries...';
            
            // Clear previous layers
            baseLayer.clearLayers();
            overlayLayer.clearLayers();
            results.innerHTML = '';
            
            const baseCity = getCityData(baseKey);
            const overlayCity = getCityData(overlayKey);
            
            currentBase = baseKey;
            currentOverlay = overlayKey;
            
            try {
                // Reset transformation state
                overlayRotation = 0;
                overlayTranslation = { lat: 0, lng: 0 };
                
                // Load both city boundaries
                status.innerHTML = '<div class="spinner"></div>Loading base city boundary...';
                baseBoundaryData = await loadCityBoundary(baseKey);
                
                status.innerHTML = '<div class="spinner"></div>Loading overlay city boundary...';
                overlayBoundaryData = await loadCityBoundary(overlayKey);
                originalOverlayData = JSON.parse(JSON.stringify(overlayBoundaryData)); // Store original
                
                status.innerHTML = '<div class="spinner"></div>Creating comparison visualization...';
                
                // Add base city to map with enhanced styling
                console.log('Adding base city to map:', baseBoundaryData);
                const baseGeoJsonLayer = L.geoJSON(baseBoundaryData, {
                    style: {
                        color: baseCity.color,
                        weight: 2,
                        opacity: 0.8,
                        fillColor: baseCity.color,
                        fillOpacity: 0.2
                    }
                });
                baseLayer.addLayer(baseGeoJsonLayer);
                
                // Highlight boundary briefly when loaded
                setTimeout(() => highlightBoundary(baseGeoJsonLayer, true), 500);
                setTimeout(() => highlightBoundary(baseGeoJsonLayer, false), 3000);
                
                console.log('Base city layer added successfully');
                
                // Calculate areas for comparison
                const baseArea = calculateGeoJSONArea(baseBoundaryData);
                const overlayArea = calculateGeoJSONArea(overlayBoundaryData);
                console.log('Areas calculated:', { baseArea, overlayArea });
                
                // Transform overlay to base city center
                console.log('Transforming overlay to base city center...');
                const transformedOverlay = transformGeoJSON(
                    overlayBoundaryData, 
                    baseCity.center, 
                    1, 
                    overlayRotation, 
                    overlayTranslation
                );
                console.log('Transformation complete:', transformedOverlay);
                
                // Add transformed overlay to map
                const overlayGeoJsonLayer = L.geoJSON(transformedOverlay, {
                    style: {
                        color: overlayCity.color,
                        weight: 3,
                        opacity: 0.9,
                        fillColor: overlayCity.color,
                        fillOpacity: 0.3,
                        dashArray: '10, 5'
                    }
                });
                overlayLayer.addLayer(overlayGeoJsonLayer);
                console.log('Overlay layer added successfully');
                
                // Fit map to base city
                map.fitBounds(baseGeoJsonLayer.getBounds(), { padding: [20, 20] });
                
                // Add markers
                L.marker(baseCity.center, {
                    title: baseCity.name
                }).addTo(baseLayer).bindPopup(`<b>${baseCity.name}</b><br>Base Location<br><em>High-resolution boundaries</em>`);
                
                L.marker(baseCity.center, {
                    title: overlayCity.name
                }).addTo(overlayLayer).bindPopup(`<b>${overlayCity.name}</b><br>Overlay Location<br><em>Actual city boundaries</em>`);
                
                // Calculate area ratio
                const areaRatio = (baseArea / overlayArea);
                
                status.textContent = 'Comparison complete! Use controls below to transform overlay.';
                
                results.innerHTML = `
                    <h3>High-Resolution Boundary Comparison</h3>
                    <div class="comparison-stats">
                        <div class="stat-card">
                            <div class="stat-value" style="color: ${baseCity.color}">${baseCity.name}</div>
                            <div class="stat-label">Base City (Solid)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" style="color: ${overlayCity.color}">${overlayCity.name}</div>
                            <div class="stat-label">Overlay City (Dashed)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${areaRatio.toFixed(1)}x</div>
                            <div class="stat-label">Approximate Size Ratio</div>
                        </div>
                    </div>
                    <p style="margin-top: 20px; color: #666; font-size: 14px;">
                        <strong>Accurate Boundaries:</strong> This comparison uses high-resolution administrative boundary data. 
                        NYC includes all 5 boroughs (Manhattan, Brooklyn, Queens, Bronx, Staten Island). 
                        LA shows the official city limits. Data sources: NYC Open Data, LA GeoHub.
                    </p>
                `;
                
                // Show advanced scaling section after successful comparison
                document.getElementById('advanced-scaling').style.display = 'block';
                
            } catch (error) {
                console.error('Error in comparison:', error);
                status.textContent = 'Error loading city boundaries. Please try again.';
                results.innerHTML = `<p style="color: #d32f2f;">Failed to load boundaries: ${error.message}</p>`;
            }
        }

        function swapCities() {
            const baseValue = baseCitySelect.value;
            const overlayValue = overlayCitySelect.value;
            
            baseCitySelect.value = overlayValue;
            overlayCitySelect.value = baseValue;
            
            updateButtons();
            
            if (compareBtn.disabled === false) {
                compareCities();
            }
        }

        // Touch gesture handling for mobile devices
        const mapContainer = map.getContainer();
        let gestureState = {
            lastTapTime: 0,
            startDistance: 0,
            startAngle: 0,
            startScale: 1,
            startRotation: 0,
            isGesturing: false
        };

        // Add gesture indicator for visual feedback
        const gestureIndicator = document.createElement('div');
        gestureIndicator.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 24px;
            font-size: 15px;
            font-weight: 500;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(gestureIndicator);

        function showGestureIndicator(message) {
            gestureIndicator.textContent = message;
            gestureIndicator.style.opacity = '1';
            clearTimeout(gestureIndicator.hideTimeout);
            gestureIndicator.hideTimeout = setTimeout(() => {
                gestureIndicator.style.opacity = '0';
            }, 1500);
        }

        // Touch event handlers
        mapContainer.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1) {
                // Single touch - check for double tap
                const now = Date.now();
                const timeDiff = now - gestureState.lastTapTime;
                
                if (timeDiff < 500 && timeDiff > 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    resetPosition();
                    resetRotation();
                    showGestureIndicator('üîÑ Double-tap reset!');
                }
                gestureState.lastTapTime = now;
                
            } else if (e.touches.length === 2) {
                // Two-finger gesture
                e.preventDefault();
                e.stopPropagation();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                gestureState.startDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                gestureState.startAngle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                ) * 180 / Math.PI;
                
                gestureState.startRotation = overlayRotation;
                gestureState.isGesturing = true;
                
                showGestureIndicator('ü§å Two-finger gesture');
            }
        }, { passive: false });

        mapContainer.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2 && gestureState.isGesturing) {
                e.preventDefault();
                e.stopPropagation();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate current distance for scaling (future feature)
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Calculate rotation
                const currentAngle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                ) * 180 / Math.PI;
                
                let deltaAngle = currentAngle - gestureState.startAngle;
                if (deltaAngle > 180) deltaAngle -= 360;
                if (deltaAngle < -180) deltaAngle += 360;
                
                if (Math.abs(deltaAngle) > 2) {
                    // Invert delta to match core rotation math (clockwise finger movement = clockwise rotation)
                    let newRotation = gestureState.startRotation - Math.round(deltaAngle);
                    if (newRotation > 180) newRotation -= 360;
                    if (newRotation < -180) newRotation += 360;
                    
                    // Check for snap-to-grid
                    const snappedRotation = showSnapGuide(newRotation);
                    
                    overlayRotation = snappedRotation;
                    updateOverlayDisplay();
                    
                    if (snappedRotation !== newRotation) {
                        showGestureIndicator(`üìê Snapped to ${snappedRotation}¬∞`);
                    } else {
                        showGestureIndicator(`üîÑ Rotate: ${overlayRotation}¬∞`);
                    }
                }
            }
        }, { passive: false });

        mapContainer.addEventListener('touchend', function(e) {
            if (e.touches.length < 2) {
                gestureState.isGesturing = false;
                gestureState.startDistance = 0;
                gestureState.startAngle = 0;
                
                if (e.touches.length === 0) {
                    showGestureIndicator('‚úã Gesture complete');
                }
            }
        }, { passive: false });

        // Simplified trackpad and desktop input support (zoom disabled)
        mapContainer.addEventListener('wheel', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            if (!currentOverlay || !currentBase) {
                showGestureIndicator(`üí° Load cities first, then use Shift + scroll to rotate`);
                return;
            }
            
            const delta = e.deltaY;
            const isRotationGesture = e.shiftKey || e.metaKey; // Shift or Cmd key for rotation
            
            if (isRotationGesture) {
                // Trackpad rotation with Shift/Cmd key
                const rotationSensitivity = 0.2; // Further reduced for precise control
                const rotationChange = Math.round(-delta * rotationSensitivity); // Negate for intuitive direction
                
                let newRotation = overlayRotation + rotationChange;
                if (newRotation > 180) newRotation -= 360;
                if (newRotation < -180) newRotation += 360;
                
                // Check for snap-to-grid
                const snappedRotation = showSnapGuide(newRotation);
                
                overlayRotation = snappedRotation;
                updateOverlayDisplay();
                
                if (snappedRotation !== newRotation) {
                    showGestureIndicator(`üìê Trackpad snap: ${snappedRotation}¬∞`);
                } else {
                    showGestureIndicator(`üñ±Ô∏è Trackpad rotate: ${overlayRotation}¬∞`);
                }
            } else {
                // Show help message for normal scroll
                showGestureIndicator(`üí° Hold Shift + scroll to rotate overlay`);
            }
        }, { passive: false });

        // Pointer events for better device support
        let pointerState = {
            isPointerDown: false,
            startPointer: null,
            isDragging: false,
            dragStartTranslation: null
        };

        mapContainer.addEventListener('pointerdown', function(e) {
            if (!currentOverlay || !currentBase) return;
            
            // Only handle left mouse button or primary pointer
            if (e.button !== 0 && e.pointerType === 'mouse') return;
            
            pointerState.isPointerDown = true;
            pointerState.startPointer = { x: e.clientX, y: e.clientY };
            pointerState.dragStartTranslation = { ...overlayTranslation };
            pointerState.isDragging = false;
            
            // Visual feedback for pointer down
            showGestureIndicator('üëÜ Pointer down - drag to move');
        }, { passive: false });

        mapContainer.addEventListener('pointermove', function(e) {
            if (!pointerState.isPointerDown || !currentOverlay || !currentBase) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const deltaX = e.clientX - pointerState.startPointer.x;
            const deltaY = e.clientY - pointerState.startPointer.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Start dragging if moved more than 5 pixels
            if (distance > 5) {
                pointerState.isDragging = true;
                
                // Convert pixel movement to coordinate movement
                const sensitivity = 0.001; // degrees per pixel
                const newTranslation = {
                    lng: pointerState.dragStartTranslation.lng + (deltaX * sensitivity),
                    lat: pointerState.dragStartTranslation.lat - (deltaY * sensitivity) // Invert Y for map coordinates
                };
                
                overlayTranslation = newTranslation;
                updateOverlayDisplay();
                
                showGestureIndicator(`üìç Position: ${newTranslation.lng.toFixed(3)}, ${newTranslation.lat.toFixed(3)}`);
            }
        }, { passive: false });

        mapContainer.addEventListener('pointerup', function(e) {
            if (pointerState.isDragging) {
                showGestureIndicator('‚úã Drag complete');
            }
            
            pointerState.isPointerDown = false;
            pointerState.isDragging = false;
            pointerState.startPointer = null;
            pointerState.dragStartTranslation = null;
        }, { passive: false });

        // Keyboard shortcuts for desktop users
        document.addEventListener('keydown', function(e) {
            if (!currentOverlay || !currentBase) return;
            
            // Ignore if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const step = e.shiftKey ? 15 : 5; // Larger steps with Shift key
            const moveStep = e.shiftKey ? 0.05 : 0.01; // Larger movement with Shift
            
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    if (e.metaKey || e.ctrlKey) {
                        // Rotate left (counter-clockwise) - now intuitive with negated transform
                        let newRotation = overlayRotation - step;
                        if (newRotation < -180) newRotation += 360;
                        overlayRotation = newRotation;
                        updateOverlayDisplay();
                        showGestureIndicator(`‚å®Ô∏è Rotate left: ${overlayRotation}¬∞`);
                    } else {
                        // Move left
                        overlayTranslation.lng -= moveStep;
                        updateOverlayDisplay();
                        showGestureIndicator(`‚å®Ô∏è Move left`);
                    }
                    break;
                    
                case 'ArrowRight':
                    e.preventDefault();
                    if (e.metaKey || e.ctrlKey) {
                        // Rotate right (clockwise) - now intuitive with negated transform
                        let newRotation = overlayRotation + step;
                        if (newRotation > 180) newRotation -= 360;
                        overlayRotation = newRotation;
                        updateOverlayDisplay();
                        showGestureIndicator(`‚å®Ô∏è Rotate right: ${overlayRotation}¬∞`);
                    } else {
                        // Move right
                        overlayTranslation.lng += moveStep;
                        updateOverlayDisplay();
                        showGestureIndicator(`‚å®Ô∏è Move right`);
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    overlayTranslation.lat += moveStep;
                    updateOverlayDisplay();
                    showGestureIndicator(`‚å®Ô∏è Move up`);
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    overlayTranslation.lat -= moveStep;
                    updateOverlayDisplay();
                    showGestureIndicator(`‚å®Ô∏è Move down`);
                    break;
                    
                case 'r':
                case 'R':
                    e.preventDefault();
                    resetPosition();
                    resetRotation();
                    showGestureIndicator(`‚å®Ô∏è Reset all transformations`);
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    resetPosition();
                    resetRotation();
                    showGestureIndicator(`‚å®Ô∏è Escape - Reset`);
                    break;
            }
        });

        // Collapsible controls functionality
        function toggleControls(button) {
            const content = button.nextElementSibling;
            const icon = button.querySelector('span');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.classList.add('expanded');
                icon.textContent = '‚ñº';
            } else {
                content.classList.remove('expanded');
                content.classList.add('collapsed');
                icon.textContent = '‚ñ∂';
            }
        }
        
        // Input help panel functionality
        function toggleInputHelp() {
            const helpContent = document.getElementById('helpContent');
            helpContent.classList.toggle('active');
        }

        // Advanced Scaling Functionality
        let statisticsDatabase = null;
        let isScalingMode = false;

        async function loadStatisticsDatabase() {
            if (!statisticsDatabase) {
                try {
                    const response = await fetch('./city_statistics_comprehensive.json');
                    statisticsDatabase = await response.json();
                    console.log('Loaded statistics for', statisticsDatabase.cities.length, 'cities');
                } catch (error) {
                    console.error('Failed to load statistics database:', error);
                    return null;
                }
            }
            return statisticsDatabase;
        }

        function toggleScalingOptions() {
            const options = document.getElementById('scaling-options');
            const toggle = document.getElementById('scaling-toggle');
            
            if (options.style.display === 'none') {
                options.style.display = 'block';
                toggle.textContent = '‚ñ≤';
                loadStatisticsDatabase(); // Load stats when section is opened
            } else {
                options.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }

        // Global scaling state
        let scalingEnabled = false;
        let selectedScalingMetric = null;

        function toggleScaling(state) {
            scalingEnabled = (state === 'on');
            
            // Update toggle pill styles
            const offPill = document.getElementById('scaling-off');
            const onPill = document.getElementById('scaling-on');
            const metricsSection = document.getElementById('scaling-metrics-section');
            const scalingActions = document.getElementById('scaling-actions');
            
            if (scalingEnabled) {
                // Scaling ON
                offPill.classList.remove('active');
                offPill.style.background = 'white';
                offPill.style.borderColor = '#dee2e6';
                
                onPill.classList.add('active');
                onPill.style.background = '#28a745';
                onPill.style.borderColor = '#28a745';
                onPill.style.color = 'white';
                
                metricsSection.style.display = 'block';
                scalingActions.style.display = 'block';
            } else {
                // Scaling OFF
                onPill.classList.remove('active');
                onPill.style.background = 'white';
                onPill.style.borderColor = '#dee2e6';
                onPill.style.color = '#495057';
                
                offPill.classList.add('active');
                offPill.style.background = '#f8f9fa';
                offPill.style.borderColor = '#dee2e6';
                
                metricsSection.style.display = 'none';
                scalingActions.style.display = 'none';
                
                // Reset scaling if currently applied
                if (isScalingMode) {
                    resetScaling();
                }
                
                // Clear selected metric and preview
                selectedScalingMetric = null;
                clearMetricPills();
                document.getElementById('scaling-preview').style.display = 'none';
            }
        }

        function selectScalingMetric(metric) {
            selectedScalingMetric = metric;
            
            // Update pill styles
            clearMetricPills();
            const selectedPill = document.querySelector(`[data-metric="${metric}"]`);
            selectedPill.style.background = '#007bff';
            selectedPill.style.borderColor = '#007bff';
            selectedPill.style.color = 'white';
            
            // Auto-apply scaling
            updateScalingPreview();
            setTimeout(() => {
                if (document.getElementById('scaling-preview').style.display !== 'none') {
                    applyScaling();
                }
            }, 100);
        }

        function clearMetricPills() {
            const pills = document.querySelectorAll('.metric-pill');
            pills.forEach(pill => {
                pill.style.background = 'white';
                pill.style.borderColor = '#dee2e6';
                pill.style.color = '#495057';
            });
        }

        async function updateScalingPreview() {
            const metric = selectedScalingMetric;
            const preview = document.getElementById('scaling-preview');
            const explanation = document.getElementById('scaling-explanation');
            const details = document.getElementById('scaling-details');

            if (!metric || !currentBase || !currentOverlay) {
                preview.style.display = 'none';
                return;
            }

            const stats = await loadStatisticsDatabase();
            if (!stats) {
                preview.style.display = 'none';
                return;
            }

            const baseCity = getCityData(currentBase);
            const overlayCity = getCityData(currentOverlay);
            
            // Find statistics for both cities
            const baseStats = stats.cities.find(city => 
                city.basic_info.name.toLowerCase().includes(baseCity.name.toLowerCase().split(',')[0])
            );
            const overlayStats = stats.cities.find(city => 
                city.basic_info.name.toLowerCase().includes(overlayCity.name.toLowerCase().split(',')[0])
            );

            if (!baseStats || !overlayStats) {
                explanation.innerHTML = `Statistics not available for these cities yet.`;
                details.innerHTML = `We're expanding our statistics database. Some cities may not have detailed metrics.`;
                preview.style.display = 'block';
                return;
            }

            // Calculate scaling based on metric
            const scaling = calculateScaling(baseStats, overlayStats, metric);
            
            explanation.innerHTML = `To match ${baseCity.name}'s ${getMetricName(metric)}, ${overlayCity.name} would appear <strong>${scaling.factor}√ó</strong> ${scaling.comparison} on the map.`;
            details.innerHTML = `${baseCity.name}: ${scaling.baseValue} ‚Ä¢ ${overlayCity.name}: ${scaling.overlayValue}`;
            
            preview.style.display = 'block';
        }

        function calculateScaling(baseStats, overlayStats, metric) {
            let baseValue, overlayValue, baseArea, scaling;
            
            switch(metric) {
                case 'population_density':
                    baseValue = baseStats.demographics.population_density;
                    overlayValue = overlayStats.demographics.population_density;
                    // To match base city's density, overlay city area needs this scaling factor
                    scaling = overlayValue / baseValue;
                    return {
                        factor: scaling.toFixed(1),
                        comparison: scaling > 1 ? 'larger' : 'smaller',
                        baseValue: `${baseValue.toLocaleString()} people/km¬≤`,
                        overlayValue: `${overlayValue.toLocaleString()} people/km¬≤`
                    };
                    
                case 'economic_density':
                    baseArea = baseStats.geography.area_city_km2;
                    const overlayArea = overlayStats.geography.area_city_km2;
                    baseValue = baseStats.economic.gdp_billions_usd * 1000 / baseArea; // Million per km¬≤
                    overlayValue = overlayStats.economic.gdp_billions_usd * 1000 / overlayArea;
                    scaling = overlayValue / baseValue;
                    return {
                        factor: scaling.toFixed(1),
                        comparison: scaling > 1 ? 'larger' : 'smaller',
                        baseValue: `$${baseValue.toFixed(1)}M/km¬≤`,
                        overlayValue: `$${overlayValue.toFixed(1)}M/km¬≤`
                    };
                    
                case 'cultural_density':
                    baseArea = baseStats.geography.area_city_km2;
                    const overlayArea2 = overlayStats.geography.area_city_km2;
                    baseValue = baseStats.infrastructure.museums / baseArea;
                    overlayValue = overlayStats.infrastructure.museums / overlayArea2;
                    scaling = overlayValue / baseValue;
                    return {
                        factor: scaling.toFixed(1),
                        comparison: scaling > 1 ? 'larger' : 'smaller',
                        baseValue: `${baseValue.toFixed(2)} museums/km¬≤`,
                        overlayValue: `${overlayValue.toFixed(2)} museums/km¬≤`
                    };
                    
                case 'transit_density':
                    baseArea = baseStats.geography.area_city_km2;
                    const overlayArea3 = overlayStats.geography.area_city_km2;
                    baseValue = baseStats.infrastructure.metro_stations / baseArea;
                    overlayValue = overlayStats.infrastructure.metro_stations / overlayArea3;
                    scaling = overlayValue / baseValue;
                    return {
                        factor: scaling.toFixed(1),
                        comparison: scaling > 1 ? 'larger' : 'smaller',
                        baseValue: `${baseValue.toFixed(2)} stations/km¬≤`,
                        overlayValue: `${overlayValue.toFixed(2)} stations/km¬≤`
                    };
            }
        }

        function getMetricName(metric) {
            const names = {
                'population_density': 'population density',
                'economic_density': 'economic density',
                'cultural_density': 'cultural density',
                'transit_density': 'transit density'
            };
            return names[metric] || metric;
        }

        async function applyScaling() {
            const metric = selectedScalingMetric;
            if (!metric || !currentBase || !currentOverlay) return;

            const stats = await loadStatisticsDatabase();
            if (!stats) return;

            // Get statistics for both cities
            const baseCity = getCityData(currentBase);
            const overlayCity = getCityData(currentOverlay);
            
            const baseStats = stats.cities.find(city => 
                city.basic_info.name.toLowerCase().includes(baseCity.name.toLowerCase().split(',')[0])
            );
            const overlayStats = stats.cities.find(city => 
                city.basic_info.name.toLowerCase().includes(overlayCity.name.toLowerCase().split(',')[0])
            );

            if (!baseStats || !overlayStats) {
                alert('Statistics not available for these cities yet.');
                return;
            }

            // Calculate scaling factor
            const scaling = calculateScaling(baseStats, overlayStats, metric);
            const areaScalingFactor = parseFloat(scaling.factor);
            
            // Convert area scaling to linear scaling (square root for 2D scaling)
            const linearScalingFactor = Math.sqrt(areaScalingFactor);
            
            console.log(`Area scaling: ${areaScalingFactor.toFixed(3)}x ‚Üí Linear scaling: ${linearScalingFactor.toFixed(3)}x`);
            
            // Apply geometric scaling to overlay boundary with safety checks
            console.log(`Applying linear scaling factor: ${linearScalingFactor} to ${overlayCity.name}`);
            
            // Limit extreme scaling to prevent coordinate bounds issues
            let actualScalingFactor = linearScalingFactor;
            if (linearScalingFactor > 10) {
                actualScalingFactor = 10; // Cap at 10x linear scaling
                console.warn(`Scaling factor capped at 10x to prevent rendering issues (was ${linearScalingFactor.toFixed(2)}x)`);
            } else if (linearScalingFactor < 0.1) {
                actualScalingFactor = 0.1; // Floor at 0.1x linear scaling  
                console.warn(`Scaling factor floored at 0.1x to prevent rendering issues (was ${linearScalingFactor.toFixed(2)}x)`);
            }
            
            const scaledBoundary = scaleGeoJSONBoundary(overlayBoundaryData, actualScalingFactor);
            
            // Align the scaled overlay to the base city's centroid
            const baseCentroid = calculateGeoJSONCentroid(baseBoundaryData);
            const scaledOverlayCentroid = calculateGeoJSONCentroid(scaledBoundary);
            const alignedBoundary = alignGeoJSONToTarget(scaledBoundary, scaledOverlayCentroid, baseCentroid);
            
            console.log(`Base centroid: [${baseCentroid.lat.toFixed(4)}, ${baseCentroid.lng.toFixed(4)}]`);
            console.log(`Scaled overlay centroid: [${scaledOverlayCentroid.lat.toFixed(4)}, ${scaledOverlayCentroid.lng.toFixed(4)}]`);
            console.log(`Aligning overlay to base city center for proper comparison`);
            
            // Clear and redraw overlay with aligned scaled boundary
            overlayLayer.clearLayers();
            const scaledGeoJsonLayer = L.geoJSON(alignedBoundary, {
                style: {
                    color: overlayCity.color,
                    weight: 3,  // Thicker line to ensure visibility
                    opacity: 1.0,
                    fillColor: overlayCity.color,
                    fillOpacity: 0.4,  // More opaque
                    dashArray: '8,8'  // Dashed to show it's scaled
                }
            });
            
            // Validate the layer was created successfully
            console.log('Scaled GeoJSON layer created with features:', scaledGeoJsonLayer.getLayers().length);
            overlayLayer.addLayer(scaledGeoJsonLayer);
            console.log('Overlay layer now has features:', overlayLayer.getLayers().length);
            
            // Debug: Try to fit just the scaled layer to verify it exists
            try {
                const scaledBounds = scaledGeoJsonLayer.getBounds();
                console.log(`Scaled layer bounds:`, scaledBounds);
                console.log(`Scaled layer valid:`, scaledBounds.isValid());
                
                // Alternative: If main bounds calculation fails, at least show the scaled boundary
                setTimeout(() => {
                    if (overlayLayer.getLayers().length === 0) {
                        console.error('Overlay layer is empty after scaling!');
                    } else {
                        console.log('Overlay layer contains scaled boundary');
                        // Fallback: ensure visibility by fitting to scaled boundary
                        try {
                            map.fitBounds(scaledBounds, {padding: [50, 50]});
                            console.log('Applied fallback map bounds to scaled boundary');
                        } catch (fallbackError) {
                            console.error('Fallback bounds setting failed:', fallbackError);
                        }
                    }
                }, 100);
            } catch (error) {
                console.error('Error with scaled layer bounds:', error);
            }
            
            // Debug: Log layer status before bounds calculation
            console.log(`Base layer has ${baseLayer.getLayers().length} features`);
            console.log(`Overlay layer has ${overlayLayer.getLayers().length} features`);
            
            // Calculate bounds more carefully
            try {
                const allLayers = L.featureGroup([baseLayer, overlayLayer]);
                const bounds = allLayers.getBounds();
                console.log(`Calculated bounds:`, bounds);
                
                // Check if bounds are reasonable (not spanning entire world)
                const latSpan = bounds.getNorth() - bounds.getSouth();
                const lngSpan = bounds.getEast() - bounds.getWest();
                console.log(`Bounds span: ${latSpan.toFixed(2)}¬∞ lat, ${lngSpan.toFixed(2)}¬∞ lng`);
                
                if (latSpan < 180 && lngSpan < 360) {
                    map.fitBounds(bounds, {padding: [20, 20]});
                } else {
                    console.warn('Bounds too large, keeping current map view');
                }
            } catch (error) {
                console.error('Error calculating bounds:', error);
            }
            
            // Update status and UI with appropriate warnings
            let statusColor = '#28a745';
            let statusIcon = '‚úÖ';
            let warningMessage = '';
            
            if (actualScalingFactor !== linearScalingFactor) {
                statusColor = '#ffc107';
                statusIcon = '‚ö†Ô∏è';
                if (actualScalingFactor === 10) {
                    warningMessage = `<div style="font-size: 11px; margin-top: 3px; color: #e67e22;">Scaling limited to 10√ó maximum to ensure visibility</div>`;
                } else if (actualScalingFactor === 0.1) {
                    warningMessage = `<div style="font-size: 11px; margin-top: 3px; color: #e67e22;">Scaling limited to 0.1√ó minimum to ensure visibility</div>`;
                }
            }
            
            status.innerHTML = `<div style="color: ${statusColor}; font-weight: 600;">
                ${statusIcon} Applied ${getMetricName(metric)} scaling: ${overlayCity.name} area scaled ${areaScalingFactor.toFixed(2)}√ó to match density
                <div style="font-size: 12px; margin-top: 5px; color: #666;">
                    Linear dimensions scaled ${actualScalingFactor.toFixed(2)}√ó ‚Ä¢ Area scaled ${areaScalingFactor.toFixed(2)}√ó ‚Ä¢ Dashed boundary shows result
                </div>
                ${warningMessage}
            </div>`;
            
            isScalingMode = true;
            document.getElementById('reset-scaling').style.background = '#dc3545';
            document.getElementById('apply-scaling').disabled = true;
            document.getElementById('apply-scaling').textContent = 'Scaling Applied ‚úì';
        }

        function scaleGeoJSONBoundary(geojson, scalingFactor) {
            /**
             * Scale GeoJSON boundary by a given factor around its centroid
             * scalingFactor < 1: makes boundary smaller
             * scalingFactor > 1: makes boundary larger
             */
            const scaled = JSON.parse(JSON.stringify(geojson)); // Deep clone
            
            // Calculate centroid of the boundary
            const centroid = calculateGeoJSONCentroid(geojson);
            console.log(`Original centroid: [${centroid.lat.toFixed(4)}, ${centroid.lng.toFixed(4)}]`);
            console.log(`Scaling factor: ${scalingFactor}`);
            
            // First pass: count total coordinates and potential out-of-bounds
            let totalCoordCount = 0;
            let wouldBeOutOfBoundsCount = 0;
            
            function countCoordinates(coords) {
                if (typeof coords[0] === 'number') {
                    totalCoordCount++;
                    const [lng, lat] = coords;
                    const deltaLng = (lng - centroid.lng) * scalingFactor;
                    const deltaLat = (lat - centroid.lat) * scalingFactor;
                    const newLng = centroid.lng + deltaLng;
                    const newLat = centroid.lat + deltaLat;
                    
                    if (Math.abs(newLng) > 179.9 || Math.abs(newLat) > 89.9) {
                        wouldBeOutOfBoundsCount++;
                    }
                } else {
                    coords.forEach(countCoordinates);
                }
            }
            
            // Count coordinates in all geometries
            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        countCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (geojson.type === 'Feature') {
                if (geojson.geometry && geojson.geometry.coordinates) {
                    countCoordinates(geojson.geometry.coordinates);
                }
            } else if (geojson.coordinates) {
                countCoordinates(geojson.coordinates);
            }
            
            // Check if too many coordinates would be out of bounds
            const outOfBoundsPercentage = (wouldBeOutOfBoundsCount / totalCoordCount) * 100;
            console.log(`Coordinate analysis: ${wouldBeOutOfBoundsCount}/${totalCoordCount} (${outOfBoundsPercentage.toFixed(1)}%) would be out of bounds`);
            
            if (outOfBoundsPercentage > 25) {
                console.error(`Scaling would put ${outOfBoundsPercentage.toFixed(1)}% of coordinates out of bounds - boundary may not render properly`);
            }
            
            // Apply scaling transformation to all coordinates with bounds checking
            let outOfBoundsCount = 0;
            function scaleCoordinates(coords) {
                if (typeof coords[0] === 'number') {
                    // This is a [lng, lat] coordinate pair
                    const [lng, lat] = coords;
                    const deltaLng = (lng - centroid.lng) * scalingFactor;
                    const deltaLat = (lat - centroid.lat) * scalingFactor;
                    let newLng = centroid.lng + deltaLng;
                    let newLat = centroid.lat + deltaLat;
                    
                    // Clamp coordinates to valid geographic bounds to prevent Leaflet rendering issues
                    const originalNewLng = newLng;
                    const originalNewLat = newLat;
                    
                    newLng = Math.max(-179.9, Math.min(179.9, newLng));
                    newLat = Math.max(-89.9, Math.min(89.9, newLat));
                    
                    // Count out-of-bounds coordinates
                    if (newLng !== originalNewLng || newLat !== originalNewLat) {
                        outOfBoundsCount++;
                        if (outOfBoundsCount <= 3) { // Only log first few to avoid spam
                            console.warn(`Clamped coordinates: [${originalNewLng.toFixed(4)}, ${originalNewLat.toFixed(4)}] ‚Üí [${newLng.toFixed(4)}, ${newLat.toFixed(4)}]`);
                        }
                    }
                    
                    return [newLng, newLat];
                } else {
                    // This is an array of coordinates, recurse
                    return coords.map(scaleCoordinates);
                }
            }
            
            // Apply scaling to all geometries
            if (scaled.type === 'FeatureCollection') {
                scaled.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        feature.geometry.coordinates = scaleCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (scaled.type === 'Feature') {
                if (scaled.geometry && scaled.geometry.coordinates) {
                    scaled.geometry.coordinates = scaleCoordinates(scaled.geometry.coordinates);
                }
            } else if (scaled.coordinates) {
                scaled.coordinates = scaleCoordinates(scaled.coordinates);
            }
            
            // Validate the scaled boundary before returning
            const scaledCentroid = calculateGeoJSONCentroid(scaled);
            console.log(`Scaled centroid: [${scaledCentroid.lat.toFixed(4)}, ${scaledCentroid.lng.toFixed(4)}]`);
            
            if (outOfBoundsCount > 0) {
                console.warn(`${outOfBoundsCount} coordinates were clamped to valid geographic bounds`);
            }
            
            return scaled;
        }
        
        function alignGeoJSONToTarget(geojson, sourceCentroid, targetCentroid) {
            /**
             * Translate GeoJSON coordinates to align source centroid with target centroid
             */
            const aligned = JSON.parse(JSON.stringify(geojson)); // Deep clone
            
            // Calculate translation offsets
            const deltaLng = targetCentroid.lng - sourceCentroid.lng;
            const deltaLat = targetCentroid.lat - sourceCentroid.lat;
            
            console.log(`Translation: [${deltaLng.toFixed(4)}¬∞, ${deltaLat.toFixed(4)}¬∞]`);
            
            // Apply translation to all coordinates
            function translateCoordinates(coords) {
                if (typeof coords[0] === 'number') {
                    // This is a [lng, lat] coordinate pair
                    const [lng, lat] = coords;
                    return [lng + deltaLng, lat + deltaLat];
                } else {
                    // This is an array of coordinates, recurse
                    return coords.map(translateCoordinates);
                }
            }
            
            // Apply translation to all geometries
            if (aligned.type === 'FeatureCollection') {
                aligned.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        feature.geometry.coordinates = translateCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (aligned.type === 'Feature') {
                if (aligned.geometry && aligned.geometry.coordinates) {
                    aligned.geometry.coordinates = translateCoordinates(aligned.geometry.coordinates);
                }
            } else if (aligned.coordinates) {
                aligned.coordinates = translateCoordinates(aligned.coordinates);
            }
            
            // Validate the aligned boundary
            const alignedCentroid = calculateGeoJSONCentroid(aligned);
            console.log(`Aligned centroid: [${alignedCentroid.lat.toFixed(4)}, ${alignedCentroid.lng.toFixed(4)}]`);
            
            return aligned;
        }

        function calculateGeoJSONCentroid(geojson) {
            /**
             * Calculate the centroid of a GeoJSON boundary
             */
            let totalLng = 0, totalLat = 0, pointCount = 0;
            
            function processCoordinates(coords) {
                if (typeof coords[0] === 'number') {
                    // This is a [lng, lat] coordinate pair
                    totalLng += coords[0];
                    totalLat += coords[1];
                    pointCount++;
                } else {
                    // This is an array of coordinates, recurse
                    coords.forEach(processCoordinates);
                }
            }
            
            // Process all geometries
            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        processCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (geojson.type === 'Feature') {
                if (geojson.geometry && geojson.geometry.coordinates) {
                    processCoordinates(geojson.geometry.coordinates);
                }
            } else if (geojson.coordinates) {
                processCoordinates(geojson.coordinates);
            }
            
            return {
                lng: totalLng / pointCount,
                lat: totalLat / pointCount
            };
        }

        function resetScaling() {
            if (isScalingMode) {
                // Reset to original comparison
                isScalingMode = false;
                
                // Restore original overlay boundary
                const overlayCity = getCityData(currentOverlay);
                overlayLayer.clearLayers();
                const originalGeoJsonLayer = L.geoJSON(originalOverlayData, {
                    style: {
                        color: overlayCity.color,
                        weight: 2,
                        opacity: 0.8,
                        fillColor: overlayCity.color,
                        fillOpacity: 0.2,
                        dashArray: '8,8'
                    }
                });
                overlayLayer.addLayer(originalGeoJsonLayer);
                
                // Update status
                status.textContent = 'Restored original boundary comparison. Use controls to transform overlay.';
                
                // Clear selected metric pill if scaling is being reset
                if (!scalingEnabled) {
                    clearMetricPills();
                    selectedScalingMetric = null;
                    document.getElementById('scaling-preview').style.display = 'none';
                }
            }
        }

        // Initialize
        updateButtons();
    </script>
</body>
</html>