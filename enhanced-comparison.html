<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Enhanced City Size Comparison Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            touch-action: pan-x pan-y;
        }
        
        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        label {
            font-weight: 600;
            min-width: 120px;
        }
        
        select, button {
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            min-height: 44px;
            min-width: 44px;
        }
        
        button {
            background: #007AFF;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        button:hover {
            background: #0056CC;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        #map {
            height: 600px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        /* World Map City Selection Styles */
        .world-map-section {
            margin: 20px 0;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .world-map-section h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 1.2em;
        }

        .selection-status {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .swap-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
            color: #666;
        }

        .swap-button:hover {
            background: #e3f2fd;
            border-color: #1976d2;
            color: #1976d2;
            transform: scale(1.1);
        }

        .swap-button:active {
            transform: scale(0.95);
        }

        .swap-button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .swap-button:disabled:hover {
            background: #f5f5f5;
            border-color: #ddd;
            color: #666;
            transform: none;
        }

        .selection-step {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f5f5f5;
            border-radius: 20px;
            border: 2px solid transparent;
            transition: all 0.2s;
            cursor: pointer;
        }

        .selection-step:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .selection-step.active {
            background: #e3f2fd;
            border-color: #1976d2;
        }

        .selection-step.completed {
            background: #e8f5e8;
            border-color: #4caf50;
        }

        .selection-step.base-completed {
            background: #e8f5e8;
            border-color: #4caf50;
        }

        .selection-step.overlay-completed {
            background: #fff3e0;
            border-color: #ff9800;
        }

        .step-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #999;
            color: white;
            border-radius: 50%;
            font-size: 0.8em;
            font-weight: bold;
        }

        .selection-step.active .step-number {
            background: #1976d2;
        }

        .selection-step.completed .step-number,
        .selection-step.base-completed .step-number {
            background: #4caf50;
        }

        .selection-step.overlay-completed .step-number {
            background: #ff9800;
        }

        .step-text {
            font-weight: 500;
        }

        #worldMap {
            height: 400px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        /* City pin styles */
        .city-pin {
            background: #1976d2;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.2s;
        }

        .city-pin:hover {
            background: #1565c0;
            transform: scale(1.2);
        }

        .city-pin.base-selected {
            background: #4caf50;
            border-color: #2e7d32;
        }

        .city-pin.overlay-selected {
            background: #ff9800;
            border-color: #f57c00;
        }

        .city-pin.both-selected {
            background: linear-gradient(45deg, #4caf50 50%, #ff9800 50%);
            border-color: #333;
        }
        
        .info-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        .comparison-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007AFF;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007AFF;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Transformation controls styling */
        #transformControls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            display: none;
        }
        
        /* Collapsible controls for mobile */
        .collapsible-header {
            display: none;
            padding: 12px 16px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px;
            margin-bottom: 10px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            text-align: left;
            font-size: 16px;
        }
        
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .collapsible-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .collapsible-content.collapsed {
                max-height: 0;
                padding-top: 0;
                padding-bottom: 0;
                margin-top: 0;
                border-top: none;
            }
            
            .collapsible-content.expanded {
                max-height: 1000px;
            }
            
            .controls {
                padding: 15px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .control-group label {
                min-width: auto;
                margin-bottom: 5px;
            }
        }

        #transformControls h4 {
            margin: 0 0 15px 0;
            color: #333;
        }

        #transformControls input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
        
        /* Enhanced Visual Feedback */
        .transformation-preview {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            font-size: 14px;
            min-width: 200px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }
        
        .transformation-preview.active {
            opacity: 1;
            transform: translateX(0);
        }
        
        .transform-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .transform-stat:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .transform-label {
            font-weight: 600;
            color: #333;
        }
        
        .transform-value {
            color: #007AFF;
            font-weight: 500;
        }
        
        /* Boundary highlight effects */
        .boundary-highlight {
            animation: boundaryPulse 2s ease-in-out infinite;
        }
        
        @keyframes boundaryPulse {
            0%, 100% { 
                stroke-width: 2;
                stroke-opacity: 0.8;
            }
            50% { 
                stroke-width: 4;
                stroke-opacity: 1;
            }
        }
        
        /* Snap guides */
        .snap-guide {
            stroke: #FF9500;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            opacity: 0.7;
            animation: snapGuideFlash 0.5s ease-in-out;
        }
        
        @keyframes snapGuideFlash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        /* Input Methods Help Panel */
        .input-help-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .help-toggle {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #007AFF;
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }
        
        .help-toggle:hover {
            background: #0056CC;
            transform: scale(1.05);
        }
        
        .help-content {
            position: absolute;
            bottom: 50px;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 250px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .help-content.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        .help-content h4 {
            margin: 0 0 12px 0;
            color: #333;
            font-size: 16px;
        }
        
        .help-section {
            margin-bottom: 12px;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .help-section:last-child {
            margin-bottom: 0;
        }
        
        .help-section strong {
            color: #007AFF;
        }
        
        @media (max-width: 768px) {
            .input-help-panel {
                bottom: 80px;
                right: 15px;
            }
            
            .help-content {
                right: -100px;
                min-width: 200px;
            }
        }

        #transformControls button {
            min-width: 40px;
            height: 40px;
            font-size: 16px;
        }

        .move-grid {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            gap: 5px;
            justify-content: start;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🗺️ Enhanced City Size Comparison Tool</h1>
        <p style="text-align: center; color: #666; margin-bottom: 30px;">
            Compare actual city boundaries with rotation and translation controls
        </p>
        
        <!-- Hidden elements for backend functionality -->
        <select id="baseCity" style="display: none;">
            <option value="">Loading cities...</option>
        </select>
        <select id="overlayCity" style="display: none;">
            <option value="">Loading cities...</option>
        </select>
        <button id="compareBtn" style="display: none;">Compare Cities</button>
        <button id="swapBtn" style="display: none;">Swap Cities</button>
        
        <!-- World Map City Selection -->
        <div class="world-map-section">
            <h3>Select Cities by Clicking on the Map</h3>
            <div class="selection-status">
                <div class="selection-step">
                    <span class="step-number">1</span>
                    <span class="step-text" id="baseStatus">Select base city</span>
                </div>
                <button class="swap-button" id="swapCitiesBtn" title="Swap base and overlay cities">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M17 17l4-4-4-4"/>
                        <path d="M7 7l-4 4 4 4"/>
                        <path d="M21 13H3"/>
                        <path d="M3 11h18"/>
                    </svg>
                </button>
                <div class="selection-step">
                    <span class="step-number">2</span>
                    <span class="step-text" id="overlayStatus">Select overlay city</span>
                </div>
            </div>
            <div id="worldMap"></div>
        </div>
        
        <div id="map"></div>
        
        <!-- Enhanced Visual Feedback Panel -->
        <div class="transformation-preview" id="transformationPreview">
            <div class="transform-stat">
                <span class="transform-label">Rotation:</span>
                <span class="transform-value" id="previewRotation">0°</span>
            </div>
            <div class="transform-stat">
                <span class="transform-label">Position:</span>
                <span class="transform-value" id="previewPosition">Center</span>
            </div>
            <div class="transform-stat">
                <span class="transform-label">Status:</span>
                <span class="transform-value" id="previewStatus">Ready</span>
            </div>
        </div>
        
        <!-- Input Methods Help Panel -->
        <div class="input-help-panel" id="inputHelpPanel">
            <button class="help-toggle" onclick="toggleInputHelp()">?</button>
            <div class="help-content" id="helpContent">
                <h4>Input Methods</h4>
                <div class="help-section">
                    <strong>Touch (Mobile):</strong><br>
                    • Two fingers: Rotate overlay<br>
                    • Double-tap: Reset transformations
                </div>
                <div class="help-section">
                    <strong>Trackpad/Mouse:</strong><br>
                    • Shift + Scroll: Rotate overlay<br>
                    • Cmd + Scroll: Rotate overlay (Mac)<br>
                    • Click + Drag: Move overlay position<br>
                    • <em>Map zoom disabled for gestures</em>
                </div>
                <div class="help-section">
                    <strong>Keyboard:</strong><br>
                    • Arrow keys: Move overlay<br>
                    • Cmd/Ctrl + Arrows: Rotate<br>
                    • R or Escape: Reset all
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div id="status" class="loading">Select two cities to begin comparison...</div>
            <div id="comparison-results"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // City data helper function (replaced with database-driven approach)
        function getCityData(cityId) {
            if (!citiesDatabase) return null;
            const city = citiesDatabase.cities.find(c => c.id === cityId);
            if (!city) return null;
            
            return {
                name: city.name,
                center: city.coordinates,
                color: city.id === selectedBaseCity?.id ? '#FF6B6B' : '#4ECDC4',
                boundaryFile: city.boundaryFile
            };
        }

        // Initialize map with gesture controls and zoom buttons
        const map = L.map('map', {
            touchZoom: false,
            doubleClickZoom: false,
            scrollWheelZoom: false,
            boxZoom: false,
            keyboard: false,
            zoomControl: true // Enable zoom buttons for main comparison map
        }).setView([40.7128, -74.0060], 10);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19,
            attribution: '© OpenStreetMap contributors, © CARTO'
        }).addTo(map);

        // Layer groups for cities
        const baseLayer = L.layerGroup().addTo(map);
        const overlayLayer = L.layerGroup().addTo(map);

        // Initialize world map for city selection
        const worldMap = L.map('worldMap', {
            zoomControl: true // Enable zoom controls for world map
        }).setView([20, 0], 2);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 10,
            attribution: '© OpenStreetMap contributors, © CARTO'
        }).addTo(worldMap);

        // World map city selection state
        let selectedBaseCity = null;
        let selectedOverlayCity = null;
        let selectionStep = 'base'; // 'base' or 'overlay'
        const cityPins = {};
        let citiesDatabase = null;

        // UI elements
        const baseCitySelect = document.getElementById('baseCity');
        const overlayCitySelect = document.getElementById('overlayCity');
        const compareBtn = document.getElementById('compareBtn');
        const swapBtn = document.getElementById('swapBtn');
        const status = document.getElementById('status');
        const results = document.getElementById('comparison-results');

        // World map city loading and selection functions
        async function loadCitiesDatabase() {
            try {
                const response = await fetch('./cities-database.json');
                citiesDatabase = await response.json();
                createCityPins();
                populateDropdowns();
                console.log(`Loaded ${citiesDatabase.cities.length} cities`);
            } catch (error) {
                console.error('Failed to load cities database:', error);
                status.innerHTML = '<div class="error">Failed to load cities database</div>';
            }
        }

        function populateDropdowns() {
            // Clear existing options (except the first placeholder)
            baseCitySelect.innerHTML = '<option value="">Select base city...</option>';
            overlayCitySelect.innerHTML = '<option value="">Select overlay city...</option>';

            // Add all cities to both dropdowns
            citiesDatabase.cities.forEach(city => {
                const baseOption = document.createElement('option');
                baseOption.value = city.id;
                baseOption.textContent = `${city.name}, ${city.country}`;
                baseCitySelect.appendChild(baseOption);

                const overlayOption = document.createElement('option');
                overlayOption.value = city.id;
                overlayOption.textContent = `${city.name}, ${city.country}`;
                overlayCitySelect.appendChild(overlayOption);
            });
        }

        function createCityPins() {
            citiesDatabase.cities.forEach(city => {
                const [lat, lng] = city.coordinates;
                
                const pinIcon = L.divIcon({
                    className: 'city-pin',
                    html: '',
                    iconSize: [12, 12],
                    iconAnchor: [6, 6]
                });

                const marker = L.marker([lat, lng], { 
                    icon: pinIcon,
                    title: `${city.name}, ${city.country}`
                }).addTo(worldMap);

                marker.on('click', () => selectCity(city));
                cityPins[city.id] = marker;
            });
        }

        function selectCity(city) {
            // Check for deselection
            if (selectedBaseCity && city.id === selectedBaseCity.id) {
                // Deselect base city
                deselectBaseCity();
                return;
            }
            
            if (selectedOverlayCity && city.id === selectedOverlayCity.id) {
                // Deselect overlay city
                deselectOverlayCity();
                return;
            }

            if (selectionStep === 'base') {
                // Select as base city
                selectedBaseCity = city;
                baseCitySelect.value = city.id;
                updatePinStyles();
                updateSelectionStatus();
                selectionStep = 'overlay';
            } else if (selectionStep === 'overlay') {
                // Select as overlay city
                if (city.id === selectedBaseCity?.id) {
                    // Same city selected, ignore
                    return;
                }
                selectedOverlayCity = city;
                overlayCitySelect.value = city.id;
                updatePinStyles();
                updateSelectionStatus();
                
                // Auto-trigger comparison
                updateButtons();
                if (compareBtn.disabled === false) {
                    compareCities();
                }
            }
        }

        function deselectBaseCity() {
            selectedBaseCity = null;
            baseCitySelect.value = '';
            selectionStep = 'base';
            updatePinStyles();
            updateSelectionStatus();
            
            // Clear comparison if both were selected
            if (selectedOverlayCity) {
                clearComparison();
            }
        }

        function deselectOverlayCity() {
            selectedOverlayCity = null;
            overlayCitySelect.value = '';
            selectionStep = 'overlay';
            updatePinStyles();
            updateSelectionStatus();
            
            // Clear comparison
            clearComparison();
        }

        function clearComparison() {
            // Clear the maps
            baseLayer.clearLayers();
            overlayLayer.clearLayers();
            
            // Clear results
            const results = document.getElementById('comparison-results');
            if (results) {
                results.innerHTML = '';
            }
            
            // Reset map view
            map.setView([40.7128, -74.0060], 10);
        }

        function swapCities() {
            if (!selectedBaseCity || !selectedOverlayCity) {
                return; // Can't swap if both cities aren't selected
            }

            // Swap the cities
            const tempCity = selectedBaseCity;
            selectedBaseCity = selectedOverlayCity;
            selectedOverlayCity = tempCity;

            // Update the hidden selects
            baseCitySelect.value = selectedBaseCity.id;
            overlayCitySelect.value = selectedOverlayCity.id;

            // Update visual states
            updatePinStyles();
            updateSelectionStatus();
            updateSwapButtonState();

            // Re-trigger comparison with swapped cities
            updateButtons();
            if (compareBtn.disabled === false) {
                compareCities();
            }
        }

        function updateSwapButtonState() {
            const swapBtn = document.getElementById('swapCitiesBtn');
            if (selectedBaseCity && selectedOverlayCity) {
                swapBtn.disabled = false;
            } else {
                swapBtn.disabled = true;
            }
        }

        function updatePinStyles() {
            // Reset all pins by removing selection classes
            Object.values(cityPins).forEach(pin => {
                const element = pin.getElement();
                element.classList.remove('base-selected', 'overlay-selected', 'both-selected');
            });

            // Style selected pins
            if (selectedBaseCity && cityPins[selectedBaseCity.id]) {
                const basePin = cityPins[selectedBaseCity.id].getElement();
                if (selectedOverlayCity && selectedBaseCity.id === selectedOverlayCity.id) {
                    basePin.classList.add('both-selected');
                } else {
                    basePin.classList.add('base-selected');
                }
            }

            if (selectedOverlayCity && selectedOverlayCity.id !== selectedBaseCity?.id && cityPins[selectedOverlayCity.id]) {
                cityPins[selectedOverlayCity.id].getElement().classList.add('overlay-selected');
            }
        }

        function updateSelectionStatus() {
            const baseStatus = document.getElementById('baseStatus');
            const overlayStatus = document.getElementById('overlayStatus');
            const baseStep = baseStatus.parentElement;
            const overlayStep = overlayStatus.parentElement;

            // Reset all step classes
            baseStep.classList.remove('completed', 'base-completed', 'overlay-completed', 'active');
            overlayStep.classList.remove('completed', 'base-completed', 'overlay-completed', 'active');

            // Update base city status
            if (selectedBaseCity) {
                baseStatus.textContent = `${selectedBaseCity.name}, ${selectedBaseCity.country}`;
                baseStep.classList.add('base-completed');
            } else {
                baseStatus.textContent = 'Select base city';
                baseStep.classList.add('active');
            }

            // Update overlay city status
            if (selectedOverlayCity) {
                overlayStatus.textContent = `${selectedOverlayCity.name}, ${selectedOverlayCity.country}`;
                overlayStep.classList.add('overlay-completed');
            } else {
                overlayStatus.textContent = 'Select overlay city';
                if (selectedBaseCity) {
                    overlayStep.classList.add('active');
                }
            }

            // Update swap button state
            updateSwapButtonState();
        }

        // Initialize the world map when page loads
        loadCitiesDatabase();

        // Add click handlers for selection pills and swap button
        document.addEventListener('DOMContentLoaded', function() {
            const baseStep = document.querySelector('#baseStatus').parentElement;
            const overlayStep = document.querySelector('#overlayStatus').parentElement;
            const swapButton = document.querySelector('#swapCitiesBtn');

            baseStep.addEventListener('click', function() {
                if (selectedBaseCity) {
                    deselectBaseCity();
                }
            });

            overlayStep.addEventListener('click', function() {
                if (selectedOverlayCity) {
                    deselectOverlayCity();
                }
            });

            swapButton.addEventListener('click', function() {
                swapCities();
            });

            // Initialize swap button state
            updateSwapButtonState();
        });

        // Transformation controls (gesture-only)

        // Transformation state
        let currentBase = null;
        let currentOverlay = null;
        let baseBoundaryData = null;
        let overlayBoundaryData = null;
        let originalOverlayData = null;
        let overlayRotation = 0;
        let overlayTranslation = { lat: 0, lng: 0 };

        // Event listeners
        baseCitySelect.addEventListener('change', updateButtons);
        overlayCitySelect.addEventListener('change', updateButtons);
        compareBtn.addEventListener('click', compareCities);
        swapBtn.addEventListener('click', swapCities);


        function updateButtons() {
            const hasBase = baseCitySelect.value;
            const hasOverlay = overlayCitySelect.value;
            const different = hasBase !== hasOverlay;
            
            compareBtn.disabled = !(hasBase && hasOverlay && different);
            swapBtn.disabled = !(hasBase && hasOverlay);
        }

        // Transformation functions (gesture-controlled)
        function resetRotation() {
            overlayRotation = 0;
            updateOverlayDisplay();
        }

        function resetPosition() {
            overlayTranslation = { lat: 0, lng: 0 };
            updateOverlayDisplay();
        }

        function updateOverlayDisplay() {
            if (!originalOverlayData || !baseBoundaryData) return;
            
            // Clear existing overlay
            overlayLayer.clearLayers();
            
            const baseCity = getCityData(currentBase);
            const overlayCity = getCityData(currentOverlay);
            
            // Transform overlay with current rotation and translation
            const transformedOverlay = transformGeoJSON(
                originalOverlayData, 
                baseCity.center, 
                1, 
                overlayRotation, 
                overlayTranslation
            );
            
            // Add transformed overlay to map with enhanced styling
            const overlayGeoJsonLayer = L.geoJSON(transformedOverlay, {
                style: {
                    color: overlayCity.color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: overlayCity.color,
                    fillOpacity: 0.3,
                    dashArray: '10, 5'
                }
            });
            overlayLayer.addLayer(overlayGeoJsonLayer);
            
            // Update transformation preview
            updateTransformationPreview();
            
            // Add smooth transition effect
            const overlayElement = overlayGeoJsonLayer.getElement?.();
            if (overlayElement) {
                overlayElement.style.transition = 'all 0.2s ease-out';
            }
        }
        
        function updateTransformationPreview() {
            const preview = document.getElementById('transformationPreview');
            const rotationElement = document.getElementById('previewRotation');
            const positionElement = document.getElementById('previewPosition');
            const statusElement = document.getElementById('previewStatus');
            
            if (currentOverlay && currentBase) {
                preview.classList.add('active');
                rotationElement.textContent = `${overlayRotation}°`;
                
                // Calculate position description
                const totalOffset = Math.sqrt(overlayTranslation.lat ** 2 + overlayTranslation.lng ** 2);
                if (totalOffset < 0.05) {
                    positionElement.textContent = 'Center';
                } else {
                    positionElement.textContent = `Offset ${totalOffset.toFixed(2)}°`;
                }
                
                // Update status based on transformation
                if (overlayRotation === 0 && totalOffset < 0.05) {
                    statusElement.textContent = 'Original';
                } else {
                    statusElement.textContent = 'Transformed';
                }
            } else {
                preview.classList.remove('active');
            }
        }
        
        function highlightBoundary(layer, highlight = true) {
            if (!layer) return;
            
            const element = layer.getElement?.();
            if (element) {
                if (highlight) {
                    element.classList.add('boundary-highlight');
                } else {
                    element.classList.remove('boundary-highlight');
                }
            }
        }
        
        function showSnapGuide(rotation) {
            // Show snap guides at common angles (0°, 45°, 90°, etc.)
            const snapAngles = [0, 45, 90, 135, 180, 225, 270, 315];
            const snapThreshold = 5; // degrees
            
            for (const snapAngle of snapAngles) {
                const diff = Math.abs(((rotation - snapAngle + 180) % 360) - 180);
                if (diff < snapThreshold) {
                    showGestureIndicator(`📐 Snap to ${snapAngle}°`);
                    return snapAngle;
                }
            }
            return rotation;
        }

        async function loadCityBoundary(cityKey) {
            const city = getCityData(cityKey);
            if (!city) {
                throw new Error(`Unknown city: ${cityKey}`);
            }
            
            try {
                const response = await fetch(city.boundaryFile);
                if (!response.ok) {
                    throw new Error(`Failed to load ${city.name} boundary data`);
                }
                
                const geojson = await response.json();
                return geojson;
            } catch (error) {
                console.error(`Error loading boundary for ${city.name}:`, error);
                throw error;
            }
        }

        function calculateGeoJSONArea(geojson) {
            // Calculate approximate area from GeoJSON coordinates
            let totalArea = 0;
            
            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    totalArea += calculateFeatureArea(feature);
                });
            } else if (geojson.type === 'Feature') {
                totalArea = calculateFeatureArea(geojson);
            }
            
            return totalArea;
        }

        function calculateFeatureArea(feature) {
            const geometry = feature.geometry;
            let area = 0;
            
            if (geometry.type === 'Polygon') {
                area = calculatePolygonArea(geometry.coordinates[0]);
            } else if (geometry.type === 'MultiPolygon') {
                geometry.coordinates.forEach(polygon => {
                    area += calculatePolygonArea(polygon[0]);
                });
            }
            
            return area;
        }

        function calculatePolygonArea(coordinates) {
            // Simple area calculation (not geodesically accurate, but good for comparison)
            if (!coordinates || coordinates.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < coordinates.length - 1; i++) {
                area += (coordinates[i][0] * coordinates[i + 1][1] - coordinates[i + 1][0] * coordinates[i][1]);
            }
            
            return Math.abs(area) / 2;
        }

        function transformGeoJSON(geojson, newCenter, scaleFactor = 1, rotation = 0, translation = { lat: 0, lng: 0 }) {
            // Calculate current centroid using a simpler approach
            let totalLat = 0, totalLon = 0, pointCount = 0;
            
            function extractPoints(coords) {
                if (typeof coords[0] === 'number') {
                    totalLon += coords[0];
                    totalLat += coords[1];
                    pointCount++;
                } else {
                    coords.forEach(extractPoints);
                }
            }
            
            // Extract all points to find centroid
            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    extractPoints(feature.geometry.coordinates);
                });
            } else if (geojson.type === 'Feature') {
                extractPoints(geojson.geometry.coordinates);
            }
            
            const currentCenter = [totalLon / pointCount, totalLat / pointCount];
            
            // Convert rotation to radians (negate for intuitive clockwise positive rotation)
            const rotationRad = (-rotation * Math.PI) / 180;
            const cos = Math.cos(rotationRad);
            const sin = Math.sin(rotationRad);
            
            // Deep clone and transform coordinates
            const transformedGeoJSON = JSON.parse(JSON.stringify(geojson));
            
            function transformCoordinates(coords) {
                if (typeof coords[0] === 'number') {
                    // This is a coordinate pair [lon, lat]
                    let deltaLon = (coords[0] - currentCenter[0]) * scaleFactor;
                    let deltaLat = (coords[1] - currentCenter[1]) * scaleFactor;
                    
                    // Apply rotation
                    if (rotation !== 0) {
                        const rotatedLon = deltaLon * cos - deltaLat * sin;
                        const rotatedLat = deltaLon * sin + deltaLat * cos;
                        deltaLon = rotatedLon;
                        deltaLat = rotatedLat;
                    }
                    
                    // Apply translation and position at new center
                    return [
                        newCenter[1] + deltaLon + translation.lng, 
                        newCenter[0] + deltaLat + translation.lat
                    ];
                } else {
                    // This is an array of coordinates
                    return coords.map(transformCoordinates);
                }
            }

            if (transformedGeoJSON.type === 'FeatureCollection') {
                transformedGeoJSON.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (transformedGeoJSON.type === 'Feature') {
                if (transformedGeoJSON.geometry && transformedGeoJSON.geometry.coordinates) {
                    transformedGeoJSON.geometry.coordinates = transformCoordinates(transformedGeoJSON.geometry.coordinates);
                }
            }

            return transformedGeoJSON;
        }

        async function compareCities() {
            const baseKey = baseCitySelect.value;
            const overlayKey = overlayCitySelect.value;
            
            if (!baseKey || !overlayKey || baseKey === overlayKey) return;
            
            status.innerHTML = '<div class="spinner"></div>Loading high-resolution city boundaries...';
            
            // Clear previous layers
            baseLayer.clearLayers();
            overlayLayer.clearLayers();
            results.innerHTML = '';
            
            const baseCity = getCityData(baseKey);
            const overlayCity = getCityData(overlayKey);
            
            currentBase = baseKey;
            currentOverlay = overlayKey;
            
            try {
                // Reset transformation state
                overlayRotation = 0;
                overlayTranslation = { lat: 0, lng: 0 };
                
                // Load both city boundaries
                status.innerHTML = '<div class="spinner"></div>Loading base city boundary...';
                baseBoundaryData = await loadCityBoundary(baseKey);
                
                status.innerHTML = '<div class="spinner"></div>Loading overlay city boundary...';
                overlayBoundaryData = await loadCityBoundary(overlayKey);
                originalOverlayData = JSON.parse(JSON.stringify(overlayBoundaryData)); // Store original
                
                status.innerHTML = '<div class="spinner"></div>Creating comparison visualization...';
                
                // Add base city to map with enhanced styling
                console.log('Adding base city to map:', baseBoundaryData);
                const baseGeoJsonLayer = L.geoJSON(baseBoundaryData, {
                    style: {
                        color: baseCity.color,
                        weight: 2,
                        opacity: 0.8,
                        fillColor: baseCity.color,
                        fillOpacity: 0.2
                    }
                });
                baseLayer.addLayer(baseGeoJsonLayer);
                
                // Highlight boundary briefly when loaded
                setTimeout(() => highlightBoundary(baseGeoJsonLayer, true), 500);
                setTimeout(() => highlightBoundary(baseGeoJsonLayer, false), 3000);
                
                console.log('Base city layer added successfully');
                
                // Calculate areas for comparison
                const baseArea = calculateGeoJSONArea(baseBoundaryData);
                const overlayArea = calculateGeoJSONArea(overlayBoundaryData);
                console.log('Areas calculated:', { baseArea, overlayArea });
                
                // Transform overlay to base city center
                console.log('Transforming overlay to base city center...');
                const transformedOverlay = transformGeoJSON(
                    overlayBoundaryData, 
                    baseCity.center, 
                    1, 
                    overlayRotation, 
                    overlayTranslation
                );
                console.log('Transformation complete:', transformedOverlay);
                
                // Add transformed overlay to map
                const overlayGeoJsonLayer = L.geoJSON(transformedOverlay, {
                    style: {
                        color: overlayCity.color,
                        weight: 3,
                        opacity: 0.9,
                        fillColor: overlayCity.color,
                        fillOpacity: 0.3,
                        dashArray: '10, 5'
                    }
                });
                overlayLayer.addLayer(overlayGeoJsonLayer);
                console.log('Overlay layer added successfully');
                
                // Fit map to base city
                map.fitBounds(baseGeoJsonLayer.getBounds(), { padding: [20, 20] });
                
                // Add markers
                L.marker(baseCity.center, {
                    title: baseCity.name
                }).addTo(baseLayer).bindPopup(`<b>${baseCity.name}</b><br>Base Location<br><em>High-resolution boundaries</em>`);
                
                L.marker(baseCity.center, {
                    title: overlayCity.name
                }).addTo(overlayLayer).bindPopup(`<b>${overlayCity.name}</b><br>Overlay Location<br><em>Actual city boundaries</em>`);
                
                // Calculate area ratio
                const areaRatio = (baseArea / overlayArea);
                
                status.textContent = 'Comparison complete! Use controls below to transform overlay.';
                
                // Show transformation controls
                transformControls.style.display = 'block';
                
                results.innerHTML = `
                    <h3>High-Resolution Boundary Comparison</h3>
                    <div class="comparison-stats">
                        <div class="stat-card">
                            <div class="stat-value" style="color: ${baseCity.color}">${baseCity.name}</div>
                            <div class="stat-label">Base City (Solid)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" style="color: ${overlayCity.color}">${overlayCity.name}</div>
                            <div class="stat-label">Overlay City (Dashed)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${areaRatio.toFixed(1)}x</div>
                            <div class="stat-label">Approximate Size Ratio</div>
                        </div>
                    </div>
                    <p style="margin-top: 20px; color: #666; font-size: 14px;">
                        <strong>Accurate Boundaries:</strong> This comparison uses high-resolution administrative boundary data. 
                        NYC includes all 5 boroughs (Manhattan, Brooklyn, Queens, Bronx, Staten Island). 
                        LA shows the official city limits. Data sources: NYC Open Data, LA GeoHub.
                    </p>
                `;
                
            } catch (error) {
                console.error('Error in comparison:', error);
                status.textContent = 'Error loading city boundaries. Please try again.';
                results.innerHTML = `<p style="color: #d32f2f;">Failed to load boundaries: ${error.message}</p>`;
            }
        }

        function swapCities() {
            const baseValue = baseCitySelect.value;
            const overlayValue = overlayCitySelect.value;
            
            baseCitySelect.value = overlayValue;
            overlayCitySelect.value = baseValue;
            
            updateButtons();
            
            if (compareBtn.disabled === false) {
                compareCities();
            }
        }

        // Touch gesture handling for mobile devices
        const mapContainer = map.getContainer();
        let gestureState = {
            lastTapTime: 0,
            startDistance: 0,
            startAngle: 0,
            startScale: 1,
            startRotation: 0,
            isGesturing: false
        };

        // Add gesture indicator for visual feedback
        const gestureIndicator = document.createElement('div');
        gestureIndicator.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 24px;
            font-size: 15px;
            font-weight: 500;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(gestureIndicator);

        function showGestureIndicator(message) {
            gestureIndicator.textContent = message;
            gestureIndicator.style.opacity = '1';
            clearTimeout(gestureIndicator.hideTimeout);
            gestureIndicator.hideTimeout = setTimeout(() => {
                gestureIndicator.style.opacity = '0';
            }, 1500);
        }

        // Touch event handlers
        mapContainer.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1) {
                // Single touch - check for double tap
                const now = Date.now();
                const timeDiff = now - gestureState.lastTapTime;
                
                if (timeDiff < 500 && timeDiff > 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    resetPosition();
                    resetRotation();
                    showGestureIndicator('🔄 Double-tap reset!');
                }
                gestureState.lastTapTime = now;
                
            } else if (e.touches.length === 2) {
                // Two-finger gesture
                e.preventDefault();
                e.stopPropagation();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                gestureState.startDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                gestureState.startAngle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                ) * 180 / Math.PI;
                
                gestureState.startRotation = overlayRotation;
                gestureState.isGesturing = true;
                
                showGestureIndicator('🤌 Two-finger gesture');
            }
        }, { passive: false });

        mapContainer.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2 && gestureState.isGesturing) {
                e.preventDefault();
                e.stopPropagation();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate current distance for scaling (future feature)
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Calculate rotation
                const currentAngle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                ) * 180 / Math.PI;
                
                let deltaAngle = currentAngle - gestureState.startAngle;
                if (deltaAngle > 180) deltaAngle -= 360;
                if (deltaAngle < -180) deltaAngle += 360;
                
                if (Math.abs(deltaAngle) > 2) {
                    // Invert delta to match core rotation math (clockwise finger movement = clockwise rotation)
                    let newRotation = gestureState.startRotation - Math.round(deltaAngle);
                    if (newRotation > 180) newRotation -= 360;
                    if (newRotation < -180) newRotation += 360;
                    
                    // Check for snap-to-grid
                    const snappedRotation = showSnapGuide(newRotation);
                    
                    overlayRotation = snappedRotation;
                    updateOverlayDisplay();
                    
                    if (snappedRotation !== newRotation) {
                        showGestureIndicator(`📐 Snapped to ${snappedRotation}°`);
                    } else {
                        showGestureIndicator(`🔄 Rotate: ${overlayRotation}°`);
                    }
                }
            }
        }, { passive: false });

        mapContainer.addEventListener('touchend', function(e) {
            if (e.touches.length < 2) {
                gestureState.isGesturing = false;
                gestureState.startDistance = 0;
                gestureState.startAngle = 0;
                
                if (e.touches.length === 0) {
                    showGestureIndicator('✋ Gesture complete');
                }
            }
        }, { passive: false });

        // Simplified trackpad and desktop input support (zoom disabled)
        mapContainer.addEventListener('wheel', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            if (!currentOverlay || !currentBase) {
                showGestureIndicator(`💡 Load cities first, then use Shift + scroll to rotate`);
                return;
            }
            
            const delta = e.deltaY;
            const isRotationGesture = e.shiftKey || e.metaKey; // Shift or Cmd key for rotation
            
            if (isRotationGesture) {
                // Trackpad rotation with Shift/Cmd key
                const rotationSensitivity = 0.2; // Further reduced for precise control
                const rotationChange = Math.round(-delta * rotationSensitivity); // Negate for intuitive direction
                
                let newRotation = overlayRotation + rotationChange;
                if (newRotation > 180) newRotation -= 360;
                if (newRotation < -180) newRotation += 360;
                
                // Check for snap-to-grid
                const snappedRotation = showSnapGuide(newRotation);
                
                overlayRotation = snappedRotation;
                updateOverlayDisplay();
                
                if (snappedRotation !== newRotation) {
                    showGestureIndicator(`📐 Trackpad snap: ${snappedRotation}°`);
                } else {
                    showGestureIndicator(`🖱️ Trackpad rotate: ${overlayRotation}°`);
                }
            } else {
                // Show help message for normal scroll
                showGestureIndicator(`💡 Hold Shift + scroll to rotate overlay`);
            }
        }, { passive: false });

        // Pointer events for better device support
        let pointerState = {
            isPointerDown: false,
            startPointer: null,
            isDragging: false,
            dragStartTranslation: null
        };

        mapContainer.addEventListener('pointerdown', function(e) {
            if (!currentOverlay || !currentBase) return;
            
            // Only handle left mouse button or primary pointer
            if (e.button !== 0 && e.pointerType === 'mouse') return;
            
            pointerState.isPointerDown = true;
            pointerState.startPointer = { x: e.clientX, y: e.clientY };
            pointerState.dragStartTranslation = { ...overlayTranslation };
            pointerState.isDragging = false;
            
            // Visual feedback for pointer down
            showGestureIndicator('👆 Pointer down - drag to move');
        }, { passive: false });

        mapContainer.addEventListener('pointermove', function(e) {
            if (!pointerState.isPointerDown || !currentOverlay || !currentBase) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const deltaX = e.clientX - pointerState.startPointer.x;
            const deltaY = e.clientY - pointerState.startPointer.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Start dragging if moved more than 5 pixels
            if (distance > 5) {
                pointerState.isDragging = true;
                
                // Convert pixel movement to coordinate movement
                const sensitivity = 0.001; // degrees per pixel
                const newTranslation = {
                    lng: pointerState.dragStartTranslation.lng + (deltaX * sensitivity),
                    lat: pointerState.dragStartTranslation.lat - (deltaY * sensitivity) // Invert Y for map coordinates
                };
                
                overlayTranslation = newTranslation;
                updateOverlayDisplay();
                
                showGestureIndicator(`📍 Position: ${newTranslation.lng.toFixed(3)}, ${newTranslation.lat.toFixed(3)}`);
            }
        }, { passive: false });

        mapContainer.addEventListener('pointerup', function(e) {
            if (pointerState.isDragging) {
                showGestureIndicator('✋ Drag complete');
            }
            
            pointerState.isPointerDown = false;
            pointerState.isDragging = false;
            pointerState.startPointer = null;
            pointerState.dragStartTranslation = null;
        }, { passive: false });

        // Keyboard shortcuts for desktop users
        document.addEventListener('keydown', function(e) {
            if (!currentOverlay || !currentBase) return;
            
            // Ignore if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const step = e.shiftKey ? 15 : 5; // Larger steps with Shift key
            const moveStep = e.shiftKey ? 0.05 : 0.01; // Larger movement with Shift
            
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    if (e.metaKey || e.ctrlKey) {
                        // Rotate left (counter-clockwise) - now intuitive with negated transform
                        let newRotation = overlayRotation - step;
                        if (newRotation < -180) newRotation += 360;
                        overlayRotation = newRotation;
                        updateOverlayDisplay();
                        showGestureIndicator(`⌨️ Rotate left: ${overlayRotation}°`);
                    } else {
                        // Move left
                        overlayTranslation.lng -= moveStep;
                        updateOverlayDisplay();
                        showGestureIndicator(`⌨️ Move left`);
                    }
                    break;
                    
                case 'ArrowRight':
                    e.preventDefault();
                    if (e.metaKey || e.ctrlKey) {
                        // Rotate right (clockwise) - now intuitive with negated transform
                        let newRotation = overlayRotation + step;
                        if (newRotation > 180) newRotation -= 360;
                        overlayRotation = newRotation;
                        updateOverlayDisplay();
                        showGestureIndicator(`⌨️ Rotate right: ${overlayRotation}°`);
                    } else {
                        // Move right
                        overlayTranslation.lng += moveStep;
                        updateOverlayDisplay();
                        showGestureIndicator(`⌨️ Move right`);
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    overlayTranslation.lat += moveStep;
                    updateOverlayDisplay();
                    showGestureIndicator(`⌨️ Move up`);
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    overlayTranslation.lat -= moveStep;
                    updateOverlayDisplay();
                    showGestureIndicator(`⌨️ Move down`);
                    break;
                    
                case 'r':
                case 'R':
                    e.preventDefault();
                    resetPosition();
                    resetRotation();
                    showGestureIndicator(`⌨️ Reset all transformations`);
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    resetPosition();
                    resetRotation();
                    showGestureIndicator(`⌨️ Escape - Reset`);
                    break;
            }
        });

        // Collapsible controls functionality
        function toggleControls(button) {
            const content = button.nextElementSibling;
            const icon = button.querySelector('span');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.classList.add('expanded');
                icon.textContent = '▼';
            } else {
                content.classList.remove('expanded');
                content.classList.add('collapsed');
                icon.textContent = '▶';
            }
        }
        
        // Input help panel functionality
        function toggleInputHelp() {
            const helpContent = document.getElementById('helpContent');
            helpContent.classList.toggle('active');
        }

        // Initialize
        updateButtons();
    </script>
</body>
</html>