<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Enhanced City Size Comparison Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
            touch-action: pan-x pan-y;
        }
        
        /* Mobile-first responsive design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        label {
            font-weight: 600;
            min-width: 120px;
        }
        
        select, button {
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            min-height: 44px;
            min-width: 44px;
        }
        
        button {
            background: #007AFF;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        button:hover {
            background: #0056CC;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        #map {
            height: 600px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .info-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        .comparison-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007AFF;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #007AFF;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Transformation controls styling */
        #transformControls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            display: none;
        }
        
        /* Collapsible controls for mobile */
        .collapsible-header {
            display: none;
            padding: 12px 16px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px;
            margin-bottom: 10px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            text-align: left;
            font-size: 16px;
        }
        
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .collapsible-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .collapsible-content.collapsed {
                max-height: 0;
                padding-top: 0;
                padding-bottom: 0;
                margin-top: 0;
                border-top: none;
            }
            
            .collapsible-content.expanded {
                max-height: 1000px;
            }
            
            .controls {
                padding: 15px;
            }
            
            .control-group {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            
            .control-group label {
                min-width: auto;
                margin-bottom: 5px;
            }
        }

        #transformControls h4 {
            margin: 0 0 15px 0;
            color: #333;
        }

        #transformControls input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
        
        /* Enhanced Visual Feedback */
        .transformation-preview {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            font-size: 14px;
            min-width: 200px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }
        
        .transformation-preview.active {
            opacity: 1;
            transform: translateX(0);
        }
        
        .transform-stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .transform-stat:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .transform-label {
            font-weight: 600;
            color: #333;
        }
        
        .transform-value {
            color: #007AFF;
            font-weight: 500;
        }
        
        /* Boundary highlight effects */
        .boundary-highlight {
            animation: boundaryPulse 2s ease-in-out infinite;
        }
        
        @keyframes boundaryPulse {
            0%, 100% { 
                stroke-width: 2;
                stroke-opacity: 0.8;
            }
            50% { 
                stroke-width: 4;
                stroke-opacity: 1;
            }
        }
        
        /* Snap guides */
        .snap-guide {
            stroke: #FF9500;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            opacity: 0.7;
            animation: snapGuideFlash 0.5s ease-in-out;
        }
        
        @keyframes snapGuideFlash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }
        
        /* Input Methods Help Panel */
        .input-help-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .help-toggle {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #007AFF;
            color: white;
            border: none;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.2s ease;
        }
        
        .help-toggle:hover {
            background: #0056CC;
            transform: scale(1.05);
        }
        
        .help-content {
            position: absolute;
            bottom: 50px;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            min-width: 250px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        
        .help-content.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        .help-content h4 {
            margin: 0 0 12px 0;
            color: #333;
            font-size: 16px;
        }
        
        .help-section {
            margin-bottom: 12px;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .help-section:last-child {
            margin-bottom: 0;
        }
        
        .help-section strong {
            color: #007AFF;
        }
        
        @media (max-width: 768px) {
            .input-help-panel {
                bottom: 80px;
                right: 15px;
            }
            
            .help-content {
                right: -100px;
                min-width: 200px;
            }
        }

        #transformControls button {
            min-width: 40px;
            height: 40px;
            font-size: 16px;
        }

        .move-grid {
            display: grid;
            grid-template-columns: repeat(3, 40px);
            gap: 5px;
            justify-content: start;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è Enhanced City Size Comparison Tool</h1>
        <p style="text-align: center; color: #666; margin-bottom: 30px;">
            Compare actual city boundaries with rotation and translation controls
        </p>
        
        <div class="controls">
            <div class="control-group">
                <label for="baseCity">Base City:</label>
                <select id="baseCity">
                    <option value="">Select base city...</option>
                    <option value="new-york">New York City (5 Boroughs)</option>
                    <option value="los-angeles">Los Angeles, CA</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="overlayCity">Overlay City:</label>
                <select id="overlayCity">
                    <option value="">Select overlay city...</option>
                    <option value="new-york">New York City (5 Boroughs)</option>
                    <option value="los-angeles">Los Angeles, CA</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="compareBtn" disabled>Compare Cities</button>
                <button id="swapBtn" disabled>Swap Cities</button>
            </div>
            
            <!-- Transformation Controls -->
            <div id="transformControls">
                <button class="collapsible-header" onclick="toggleControls(this)">
                    Transform Overlay City
                    <span>‚ñº</span>
                </button>
                <div class="collapsible-content expanded">
                <h4 style="display: none;">Transform Overlay City:</h4>
                
                <div class="control-group">
                    <label>Rotation:</label>
                    <input type="range" id="rotationSlider" min="0" max="360" value="0" step="1">
                    <span id="rotationValue">0¬∞</span>
                    <button id="resetRotation">Reset</button>
                </div>
                
                <div class="control-group">
                    <label>Position:</label>
                    <div class="move-grid">
                        <button id="moveUpLeft">‚Üñ</button>
                        <button id="moveUp">‚Üë</button>
                        <button id="moveUpRight">‚Üó</button>
                        <button id="moveLeft">‚Üê</button>
                        <button id="resetPosition">‚äô</button>
                        <button id="moveRight">‚Üí</button>
                        <button id="moveDownLeft">‚Üô</button>
                        <button id="moveDown">‚Üì</button>
                        <button id="moveDownRight">‚Üò</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>Move Distance:</label>
                    <input type="range" id="moveStep" min="0.01" max="0.5" value="0.1" step="0.01">
                    <span id="moveStepValue">0.10¬∞</span>
                </div>
                </div> <!-- Close collapsible-content -->
            </div>
        </div>
        
        <div id="map"></div>
        
        <!-- Enhanced Visual Feedback Panel -->
        <div class="transformation-preview" id="transformationPreview">
            <div class="transform-stat">
                <span class="transform-label">Rotation:</span>
                <span class="transform-value" id="previewRotation">0¬∞</span>
            </div>
            <div class="transform-stat">
                <span class="transform-label">Position:</span>
                <span class="transform-value" id="previewPosition">Center</span>
            </div>
            <div class="transform-stat">
                <span class="transform-label">Status:</span>
                <span class="transform-value" id="previewStatus">Ready</span>
            </div>
        </div>
        
        <!-- Input Methods Help Panel -->
        <div class="input-help-panel" id="inputHelpPanel">
            <button class="help-toggle" onclick="toggleInputHelp()">?</button>
            <div class="help-content" id="helpContent">
                <h4>Input Methods</h4>
                <div class="help-section">
                    <strong>Touch (Mobile):</strong><br>
                    ‚Ä¢ Two fingers: Rotate overlay<br>
                    ‚Ä¢ Double-tap: Reset transformations
                </div>
                <div class="help-section">
                    <strong>Trackpad/Mouse:</strong><br>
                    ‚Ä¢ Shift + Scroll: Rotate overlay<br>
                    ‚Ä¢ Cmd + Scroll: Rotate overlay (Mac)<br>
                    ‚Ä¢ Click + Drag: Move overlay position<br>
                    ‚Ä¢ <em>Map zoom disabled for gestures</em>
                </div>
                <div class="help-section">
                    <strong>Keyboard:</strong><br>
                    ‚Ä¢ Arrow keys: Move overlay<br>
                    ‚Ä¢ Cmd/Ctrl + Arrows: Rotate<br>
                    ‚Ä¢ R or Escape: Reset all
                </div>
            </div>
        </div>
        
        <div class="info-panel">
            <div id="status" class="loading">Select two cities to begin comparison...</div>
            <div id="comparison-results"></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // City data with high-resolution boundary file references
        const CITIES = {
            'new-york': {
                name: 'New York City',
                center: [40.7128, -74.0060],
                color: '#FF6B6B',
                boundaryFile: 'nyc-boroughs.geojson'
            },
            'los-angeles': {
                name: 'Los Angeles', 
                center: [34.0522, -118.2437],
                color: '#4ECDC4',
                boundaryFile: 'los-angeles-city-only.geojson'
            }
        };

        // Initialize map with all zoom disabled for gesture focus
        const map = L.map('map', {
            touchZoom: false,
            doubleClickZoom: false,
            scrollWheelZoom: false,
            boxZoom: false,
            keyboard: false,
            zoomControl: false // Remove zoom buttons entirely
        }).setView([40.7128, -74.0060], 10);
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19,
            attribution: '¬© OpenStreetMap contributors, ¬© CARTO'
        }).addTo(map);

        // Layer groups for cities
        const baseLayer = L.layerGroup().addTo(map);
        const overlayLayer = L.layerGroup().addTo(map);

        // UI elements
        const baseCitySelect = document.getElementById('baseCity');
        const overlayCitySelect = document.getElementById('overlayCity');
        const compareBtn = document.getElementById('compareBtn');
        const swapBtn = document.getElementById('swapBtn');
        const status = document.getElementById('status');
        const results = document.getElementById('comparison-results');

        // Transformation controls
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationValue = document.getElementById('rotationValue');
        const moveStep = document.getElementById('moveStep');
        const moveStepValue = document.getElementById('moveStepValue');
        const transformControls = document.getElementById('transformControls');

        // Transformation state
        let currentBase = null;
        let currentOverlay = null;
        let baseBoundaryData = null;
        let overlayBoundaryData = null;
        let originalOverlayData = null;
        let overlayRotation = 0;
        let overlayTranslation = { lat: 0, lng: 0 };

        // Event listeners
        baseCitySelect.addEventListener('change', updateButtons);
        overlayCitySelect.addEventListener('change', updateButtons);
        compareBtn.addEventListener('click', compareCities);
        swapBtn.addEventListener('click', swapCities);

        // Transformation control event listeners
        rotationSlider.addEventListener('input', updateRotation);
        moveStep.addEventListener('input', updateMoveStep);
        
        // Movement buttons
        document.getElementById('moveUp').addEventListener('click', () => moveOverlay(0, 1));
        document.getElementById('moveDown').addEventListener('click', () => moveOverlay(0, -1));
        document.getElementById('moveLeft').addEventListener('click', () => moveOverlay(-1, 0));
        document.getElementById('moveRight').addEventListener('click', () => moveOverlay(1, 0));
        document.getElementById('moveUpLeft').addEventListener('click', () => moveOverlay(-1, 1));
        document.getElementById('moveUpRight').addEventListener('click', () => moveOverlay(1, 1));
        document.getElementById('moveDownLeft').addEventListener('click', () => moveOverlay(-1, -1));
        document.getElementById('moveDownRight').addEventListener('click', () => moveOverlay(1, -1));
        
        // Reset buttons
        document.getElementById('resetRotation').addEventListener('click', resetRotation);
        document.getElementById('resetPosition').addEventListener('click', resetPosition);

        function updateButtons() {
            const hasBase = baseCitySelect.value;
            const hasOverlay = overlayCitySelect.value;
            const different = hasBase !== hasOverlay;
            
            compareBtn.disabled = !(hasBase && hasOverlay && different);
            swapBtn.disabled = !(hasBase && hasOverlay);
        }

        // Transformation control functions
        function updateRotation() {
            overlayRotation = parseInt(rotationSlider.value);
            rotationValue.textContent = overlayRotation + '¬∞';
            updateOverlayDisplay();
        }

        function updateMoveStep() {
            const step = parseFloat(moveStep.value);
            moveStepValue.textContent = step.toFixed(2) + '¬∞';
        }

        function moveOverlay(deltaX, deltaY) {
            const step = parseFloat(moveStep.value);
            overlayTranslation.lng += deltaX * step;
            overlayTranslation.lat += deltaY * step;
            updateOverlayDisplay();
        }

        function resetRotation() {
            overlayRotation = 0;
            rotationSlider.value = 0;
            rotationValue.textContent = '0¬∞';
            updateOverlayDisplay();
        }

        function resetPosition() {
            overlayTranslation = { lat: 0, lng: 0 };
            updateOverlayDisplay();
        }

        function updateOverlayDisplay() {
            if (!originalOverlayData || !baseBoundaryData) return;
            
            // Clear existing overlay
            overlayLayer.clearLayers();
            
            const baseCity = CITIES[currentBase];
            const overlayCity = CITIES[currentOverlay];
            
            // Transform overlay with current rotation and translation
            const transformedOverlay = transformGeoJSON(
                originalOverlayData, 
                baseCity.center, 
                1, 
                overlayRotation, 
                overlayTranslation
            );
            
            // Add transformed overlay to map with enhanced styling
            const overlayGeoJsonLayer = L.geoJSON(transformedOverlay, {
                style: {
                    color: overlayCity.color,
                    weight: 3,
                    opacity: 0.9,
                    fillColor: overlayCity.color,
                    fillOpacity: 0.3,
                    dashArray: '10, 5'
                }
            });
            overlayLayer.addLayer(overlayGeoJsonLayer);
            
            // Update transformation preview
            updateTransformationPreview();
            
            // Add smooth transition effect
            const overlayElement = overlayGeoJsonLayer.getElement?.();
            if (overlayElement) {
                overlayElement.style.transition = 'all 0.2s ease-out';
            }
        }
        
        function updateTransformationPreview() {
            const preview = document.getElementById('transformationPreview');
            const rotationElement = document.getElementById('previewRotation');
            const positionElement = document.getElementById('previewPosition');
            const statusElement = document.getElementById('previewStatus');
            
            if (currentOverlay && currentBase) {
                preview.classList.add('active');
                rotationElement.textContent = `${overlayRotation}¬∞`;
                
                // Calculate position description
                const totalOffset = Math.sqrt(overlayTranslation.lat ** 2 + overlayTranslation.lng ** 2);
                if (totalOffset < 0.05) {
                    positionElement.textContent = 'Center';
                } else {
                    positionElement.textContent = `Offset ${totalOffset.toFixed(2)}¬∞`;
                }
                
                // Update status based on transformation
                if (overlayRotation === 0 && totalOffset < 0.05) {
                    statusElement.textContent = 'Original';
                } else {
                    statusElement.textContent = 'Transformed';
                }
            } else {
                preview.classList.remove('active');
            }
        }
        
        function highlightBoundary(layer, highlight = true) {
            if (!layer) return;
            
            const element = layer.getElement?.();
            if (element) {
                if (highlight) {
                    element.classList.add('boundary-highlight');
                } else {
                    element.classList.remove('boundary-highlight');
                }
            }
        }
        
        function showSnapGuide(rotation) {
            // Show snap guides at common angles (0¬∞, 45¬∞, 90¬∞, etc.)
            const snapAngles = [0, 45, 90, 135, 180, 225, 270, 315];
            const snapThreshold = 5; // degrees
            
            for (const snapAngle of snapAngles) {
                const diff = Math.abs(((rotation - snapAngle + 180) % 360) - 180);
                if (diff < snapThreshold) {
                    showGestureIndicator(`üìê Snap to ${snapAngle}¬∞`);
                    return snapAngle;
                }
            }
            return rotation;
        }

        async function loadCityBoundary(cityKey) {
            const city = CITIES[cityKey];
            if (!city) {
                throw new Error(`Unknown city: ${cityKey}`);
            }
            
            try {
                const response = await fetch(city.boundaryFile);
                if (!response.ok) {
                    throw new Error(`Failed to load ${city.name} boundary data`);
                }
                
                const geojson = await response.json();
                return geojson;
            } catch (error) {
                console.error(`Error loading boundary for ${city.name}:`, error);
                throw error;
            }
        }

        function calculateGeoJSONArea(geojson) {
            // Calculate approximate area from GeoJSON coordinates
            let totalArea = 0;
            
            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    totalArea += calculateFeatureArea(feature);
                });
            } else if (geojson.type === 'Feature') {
                totalArea = calculateFeatureArea(geojson);
            }
            
            return totalArea;
        }

        function calculateFeatureArea(feature) {
            const geometry = feature.geometry;
            let area = 0;
            
            if (geometry.type === 'Polygon') {
                area = calculatePolygonArea(geometry.coordinates[0]);
            } else if (geometry.type === 'MultiPolygon') {
                geometry.coordinates.forEach(polygon => {
                    area += calculatePolygonArea(polygon[0]);
                });
            }
            
            return area;
        }

        function calculatePolygonArea(coordinates) {
            // Simple area calculation (not geodesically accurate, but good for comparison)
            if (!coordinates || coordinates.length < 3) return 0;
            
            let area = 0;
            for (let i = 0; i < coordinates.length - 1; i++) {
                area += (coordinates[i][0] * coordinates[i + 1][1] - coordinates[i + 1][0] * coordinates[i][1]);
            }
            
            return Math.abs(area) / 2;
        }

        function transformGeoJSON(geojson, newCenter, scaleFactor = 1, rotation = 0, translation = { lat: 0, lng: 0 }) {
            // Calculate current centroid using a simpler approach
            let totalLat = 0, totalLon = 0, pointCount = 0;
            
            function extractPoints(coords) {
                if (typeof coords[0] === 'number') {
                    totalLon += coords[0];
                    totalLat += coords[1];
                    pointCount++;
                } else {
                    coords.forEach(extractPoints);
                }
            }
            
            // Extract all points to find centroid
            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    extractPoints(feature.geometry.coordinates);
                });
            } else if (geojson.type === 'Feature') {
                extractPoints(geojson.geometry.coordinates);
            }
            
            const currentCenter = [totalLon / pointCount, totalLat / pointCount];
            
            // Convert rotation to radians (negate for intuitive clockwise positive rotation)
            const rotationRad = (-rotation * Math.PI) / 180;
            const cos = Math.cos(rotationRad);
            const sin = Math.sin(rotationRad);
            
            // Deep clone and transform coordinates
            const transformedGeoJSON = JSON.parse(JSON.stringify(geojson));
            
            function transformCoordinates(coords) {
                if (typeof coords[0] === 'number') {
                    // This is a coordinate pair [lon, lat]
                    let deltaLon = (coords[0] - currentCenter[0]) * scaleFactor;
                    let deltaLat = (coords[1] - currentCenter[1]) * scaleFactor;
                    
                    // Apply rotation
                    if (rotation !== 0) {
                        const rotatedLon = deltaLon * cos - deltaLat * sin;
                        const rotatedLat = deltaLon * sin + deltaLat * cos;
                        deltaLon = rotatedLon;
                        deltaLat = rotatedLat;
                    }
                    
                    // Apply translation and position at new center
                    return [
                        newCenter[1] + deltaLon + translation.lng, 
                        newCenter[0] + deltaLat + translation.lat
                    ];
                } else {
                    // This is an array of coordinates
                    return coords.map(transformCoordinates);
                }
            }

            if (transformedGeoJSON.type === 'FeatureCollection') {
                transformedGeoJSON.features.forEach(feature => {
                    if (feature.geometry && feature.geometry.coordinates) {
                        feature.geometry.coordinates = transformCoordinates(feature.geometry.coordinates);
                    }
                });
            } else if (transformedGeoJSON.type === 'Feature') {
                if (transformedGeoJSON.geometry && transformedGeoJSON.geometry.coordinates) {
                    transformedGeoJSON.geometry.coordinates = transformCoordinates(transformedGeoJSON.geometry.coordinates);
                }
            }

            return transformedGeoJSON;
        }

        async function compareCities() {
            const baseKey = baseCitySelect.value;
            const overlayKey = overlayCitySelect.value;
            
            if (!baseKey || !overlayKey || baseKey === overlayKey) return;
            
            status.innerHTML = '<div class="spinner"></div>Loading high-resolution city boundaries...';
            
            // Clear previous layers
            baseLayer.clearLayers();
            overlayLayer.clearLayers();
            results.innerHTML = '';
            
            const baseCity = CITIES[baseKey];
            const overlayCity = CITIES[overlayKey];
            
            currentBase = baseKey;
            currentOverlay = overlayKey;
            
            try {
                // Reset transformation state
                overlayRotation = 0;
                overlayTranslation = { lat: 0, lng: 0 };
                rotationSlider.value = 0;
                rotationValue.textContent = '0¬∞';
                
                // Load both city boundaries
                status.innerHTML = '<div class="spinner"></div>Loading base city boundary...';
                baseBoundaryData = await loadCityBoundary(baseKey);
                
                status.innerHTML = '<div class="spinner"></div>Loading overlay city boundary...';
                overlayBoundaryData = await loadCityBoundary(overlayKey);
                originalOverlayData = JSON.parse(JSON.stringify(overlayBoundaryData)); // Store original
                
                status.innerHTML = '<div class="spinner"></div>Creating comparison visualization...';
                
                // Add base city to map with enhanced styling
                console.log('Adding base city to map:', baseBoundaryData);
                const baseGeoJsonLayer = L.geoJSON(baseBoundaryData, {
                    style: {
                        color: baseCity.color,
                        weight: 2,
                        opacity: 0.8,
                        fillColor: baseCity.color,
                        fillOpacity: 0.2
                    }
                });
                baseLayer.addLayer(baseGeoJsonLayer);
                
                // Highlight boundary briefly when loaded
                setTimeout(() => highlightBoundary(baseGeoJsonLayer, true), 500);
                setTimeout(() => highlightBoundary(baseGeoJsonLayer, false), 3000);
                
                console.log('Base city layer added successfully');
                
                // Calculate areas for comparison
                const baseArea = calculateGeoJSONArea(baseBoundaryData);
                const overlayArea = calculateGeoJSONArea(overlayBoundaryData);
                console.log('Areas calculated:', { baseArea, overlayArea });
                
                // Transform overlay to base city center
                console.log('Transforming overlay to base city center...');
                const transformedOverlay = transformGeoJSON(
                    overlayBoundaryData, 
                    baseCity.center, 
                    1, 
                    overlayRotation, 
                    overlayTranslation
                );
                console.log('Transformation complete:', transformedOverlay);
                
                // Add transformed overlay to map
                const overlayGeoJsonLayer = L.geoJSON(transformedOverlay, {
                    style: {
                        color: overlayCity.color,
                        weight: 3,
                        opacity: 0.9,
                        fillColor: overlayCity.color,
                        fillOpacity: 0.3,
                        dashArray: '10, 5'
                    }
                });
                overlayLayer.addLayer(overlayGeoJsonLayer);
                console.log('Overlay layer added successfully');
                
                // Fit map to base city
                map.fitBounds(baseGeoJsonLayer.getBounds(), { padding: [20, 20] });
                
                // Add markers
                L.marker(baseCity.center, {
                    title: baseCity.name
                }).addTo(baseLayer).bindPopup(`<b>${baseCity.name}</b><br>Base Location<br><em>High-resolution boundaries</em>`);
                
                L.marker(baseCity.center, {
                    title: overlayCity.name
                }).addTo(overlayLayer).bindPopup(`<b>${overlayCity.name}</b><br>Overlay Location<br><em>Actual city boundaries</em>`);
                
                // Calculate area ratio
                const areaRatio = (baseArea / overlayArea);
                
                status.textContent = 'Comparison complete! Use controls below to transform overlay.';
                
                // Show transformation controls
                transformControls.style.display = 'block';
                
                results.innerHTML = `
                    <h3>High-Resolution Boundary Comparison</h3>
                    <div class="comparison-stats">
                        <div class="stat-card">
                            <div class="stat-value" style="color: ${baseCity.color}">${baseCity.name}</div>
                            <div class="stat-label">Base City (Solid)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" style="color: ${overlayCity.color}">${overlayCity.name}</div>
                            <div class="stat-label">Overlay City (Dashed)</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value">${areaRatio.toFixed(1)}x</div>
                            <div class="stat-label">Approximate Size Ratio</div>
                        </div>
                    </div>
                    <p style="margin-top: 20px; color: #666; font-size: 14px;">
                        <strong>Accurate Boundaries:</strong> This comparison uses high-resolution administrative boundary data. 
                        NYC includes all 5 boroughs (Manhattan, Brooklyn, Queens, Bronx, Staten Island). 
                        LA shows the official city limits. Data sources: NYC Open Data, LA GeoHub.
                    </p>
                `;
                
            } catch (error) {
                console.error('Error in comparison:', error);
                status.textContent = 'Error loading city boundaries. Please try again.';
                results.innerHTML = `<p style="color: #d32f2f;">Failed to load boundaries: ${error.message}</p>`;
            }
        }

        function swapCities() {
            const baseValue = baseCitySelect.value;
            const overlayValue = overlayCitySelect.value;
            
            baseCitySelect.value = overlayValue;
            overlayCitySelect.value = baseValue;
            
            updateButtons();
            
            if (compareBtn.disabled === false) {
                compareCities();
            }
        }

        // Touch gesture handling for mobile devices
        const mapContainer = map.getContainer();
        let gestureState = {
            lastTapTime: 0,
            startDistance: 0,
            startAngle: 0,
            startScale: 1,
            startRotation: 0,
            isGesturing: false
        };

        // Add gesture indicator for visual feedback
        const gestureIndicator = document.createElement('div');
        gestureIndicator.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px 20px;
            border-radius: 24px;
            font-size: 15px;
            font-weight: 500;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        `;
        document.body.appendChild(gestureIndicator);

        function showGestureIndicator(message) {
            gestureIndicator.textContent = message;
            gestureIndicator.style.opacity = '1';
            clearTimeout(gestureIndicator.hideTimeout);
            gestureIndicator.hideTimeout = setTimeout(() => {
                gestureIndicator.style.opacity = '0';
            }, 1500);
        }

        // Touch event handlers
        mapContainer.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1) {
                // Single touch - check for double tap
                const now = Date.now();
                const timeDiff = now - gestureState.lastTapTime;
                
                if (timeDiff < 500 && timeDiff > 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    resetPosition();
                    resetRotation();
                    showGestureIndicator('üîÑ Double-tap reset!');
                }
                gestureState.lastTapTime = now;
                
            } else if (e.touches.length === 2) {
                // Two-finger gesture
                e.preventDefault();
                e.stopPropagation();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                gestureState.startDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                gestureState.startAngle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                ) * 180 / Math.PI;
                
                gestureState.startRotation = overlayRotation;
                gestureState.isGesturing = true;
                
                showGestureIndicator('ü§å Two-finger gesture');
            }
        }, { passive: false });

        mapContainer.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2 && gestureState.isGesturing) {
                e.preventDefault();
                e.stopPropagation();
                
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate current distance for scaling (future feature)
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Calculate rotation
                const currentAngle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                ) * 180 / Math.PI;
                
                let deltaAngle = currentAngle - gestureState.startAngle;
                if (deltaAngle > 180) deltaAngle -= 360;
                if (deltaAngle < -180) deltaAngle += 360;
                
                if (Math.abs(deltaAngle) > 2) {
                    // Invert delta to match core rotation math (clockwise finger movement = clockwise rotation)
                    let newRotation = gestureState.startRotation - Math.round(deltaAngle);
                    if (newRotation > 180) newRotation -= 360;
                    if (newRotation < -180) newRotation += 360;
                    
                    // Check for snap-to-grid
                    const snappedRotation = showSnapGuide(newRotation);
                    
                    overlayRotation = snappedRotation;
                    rotationSlider.value = overlayRotation;
                    rotationValue.textContent = overlayRotation + '¬∞';
                    updateOverlayDisplay();
                    
                    if (snappedRotation !== newRotation) {
                        showGestureIndicator(`üìê Snapped to ${snappedRotation}¬∞`);
                    } else {
                        showGestureIndicator(`üîÑ Rotate: ${overlayRotation}¬∞`);
                    }
                }
            }
        }, { passive: false });

        mapContainer.addEventListener('touchend', function(e) {
            if (e.touches.length < 2) {
                gestureState.isGesturing = false;
                gestureState.startDistance = 0;
                gestureState.startAngle = 0;
                
                if (e.touches.length === 0) {
                    showGestureIndicator('‚úã Gesture complete');
                }
            }
        }, { passive: false });

        // Simplified trackpad and desktop input support (zoom disabled)
        mapContainer.addEventListener('wheel', function(e) {
            e.preventDefault();
            e.stopPropagation();
            
            if (!currentOverlay || !currentBase) {
                showGestureIndicator(`üí° Load cities first, then use Shift + scroll to rotate`);
                return;
            }
            
            const delta = e.deltaY;
            const isRotationGesture = e.shiftKey || e.metaKey; // Shift or Cmd key for rotation
            
            if (isRotationGesture) {
                // Trackpad rotation with Shift/Cmd key
                const rotationSensitivity = 0.2; // Further reduced for precise control
                const rotationChange = Math.round(-delta * rotationSensitivity); // Negate for intuitive direction
                
                let newRotation = overlayRotation + rotationChange;
                if (newRotation > 180) newRotation -= 360;
                if (newRotation < -180) newRotation += 360;
                
                // Check for snap-to-grid
                const snappedRotation = showSnapGuide(newRotation);
                
                overlayRotation = snappedRotation;
                rotationSlider.value = overlayRotation;
                rotationValue.textContent = overlayRotation + '¬∞';
                updateOverlayDisplay();
                
                if (snappedRotation !== newRotation) {
                    showGestureIndicator(`üìê Trackpad snap: ${snappedRotation}¬∞`);
                } else {
                    showGestureIndicator(`üñ±Ô∏è Trackpad rotate: ${overlayRotation}¬∞`);
                }
            } else {
                // Show help message for normal scroll
                showGestureIndicator(`üí° Hold Shift + scroll to rotate overlay`);
            }
        }, { passive: false });

        // Pointer events for better device support
        let pointerState = {
            isPointerDown: false,
            startPointer: null,
            isDragging: false,
            dragStartTranslation: null
        };

        mapContainer.addEventListener('pointerdown', function(e) {
            if (!currentOverlay || !currentBase) return;
            
            // Only handle left mouse button or primary pointer
            if (e.button !== 0 && e.pointerType === 'mouse') return;
            
            pointerState.isPointerDown = true;
            pointerState.startPointer = { x: e.clientX, y: e.clientY };
            pointerState.dragStartTranslation = { ...overlayTranslation };
            pointerState.isDragging = false;
            
            // Visual feedback for pointer down
            showGestureIndicator('üëÜ Pointer down - drag to move');
        }, { passive: false });

        mapContainer.addEventListener('pointermove', function(e) {
            if (!pointerState.isPointerDown || !currentOverlay || !currentBase) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const deltaX = e.clientX - pointerState.startPointer.x;
            const deltaY = e.clientY - pointerState.startPointer.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Start dragging if moved more than 5 pixels
            if (distance > 5) {
                pointerState.isDragging = true;
                
                // Convert pixel movement to coordinate movement
                const sensitivity = 0.001; // degrees per pixel
                const newTranslation = {
                    lng: pointerState.dragStartTranslation.lng + (deltaX * sensitivity),
                    lat: pointerState.dragStartTranslation.lat - (deltaY * sensitivity) // Invert Y for map coordinates
                };
                
                overlayTranslation = newTranslation;
                updateOverlayDisplay();
                
                showGestureIndicator(`üìç Position: ${newTranslation.lng.toFixed(3)}, ${newTranslation.lat.toFixed(3)}`);
            }
        }, { passive: false });

        mapContainer.addEventListener('pointerup', function(e) {
            if (pointerState.isDragging) {
                showGestureIndicator('‚úã Drag complete');
            }
            
            pointerState.isPointerDown = false;
            pointerState.isDragging = false;
            pointerState.startPointer = null;
            pointerState.dragStartTranslation = null;
        }, { passive: false });

        // Keyboard shortcuts for desktop users
        document.addEventListener('keydown', function(e) {
            if (!currentOverlay || !currentBase) return;
            
            // Ignore if user is typing in an input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const step = e.shiftKey ? 15 : 5; // Larger steps with Shift key
            const moveStep = e.shiftKey ? 0.05 : 0.01; // Larger movement with Shift
            
            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    if (e.metaKey || e.ctrlKey) {
                        // Rotate left (counter-clockwise) - now intuitive with negated transform
                        let newRotation = overlayRotation - step;
                        if (newRotation < -180) newRotation += 360;
                        overlayRotation = newRotation;
                        rotationSlider.value = overlayRotation;
                        rotationValue.textContent = overlayRotation + '¬∞';
                        updateOverlayDisplay();
                        showGestureIndicator(`‚å®Ô∏è Rotate left: ${overlayRotation}¬∞`);
                    } else {
                        // Move left
                        overlayTranslation.lng -= moveStep;
                        updateOverlayDisplay();
                        showGestureIndicator(`‚å®Ô∏è Move left`);
                    }
                    break;
                    
                case 'ArrowRight':
                    e.preventDefault();
                    if (e.metaKey || e.ctrlKey) {
                        // Rotate right (clockwise) - now intuitive with negated transform
                        let newRotation = overlayRotation + step;
                        if (newRotation > 180) newRotation -= 360;
                        overlayRotation = newRotation;
                        rotationSlider.value = overlayRotation;
                        rotationValue.textContent = overlayRotation + '¬∞';
                        updateOverlayDisplay();
                        showGestureIndicator(`‚å®Ô∏è Rotate right: ${overlayRotation}¬∞`);
                    } else {
                        // Move right
                        overlayTranslation.lng += moveStep;
                        updateOverlayDisplay();
                        showGestureIndicator(`‚å®Ô∏è Move right`);
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    overlayTranslation.lat += moveStep;
                    updateOverlayDisplay();
                    showGestureIndicator(`‚å®Ô∏è Move up`);
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    overlayTranslation.lat -= moveStep;
                    updateOverlayDisplay();
                    showGestureIndicator(`‚å®Ô∏è Move down`);
                    break;
                    
                case 'r':
                case 'R':
                    e.preventDefault();
                    resetPosition();
                    resetRotation();
                    showGestureIndicator(`‚å®Ô∏è Reset all transformations`);
                    break;
                    
                case 'Escape':
                    e.preventDefault();
                    resetPosition();
                    resetRotation();
                    showGestureIndicator(`‚å®Ô∏è Escape - Reset`);
                    break;
            }
        });

        // Collapsible controls functionality
        function toggleControls(button) {
            const content = button.nextElementSibling;
            const icon = button.querySelector('span');
            
            if (content.classList.contains('collapsed')) {
                content.classList.remove('collapsed');
                content.classList.add('expanded');
                icon.textContent = '‚ñº';
            } else {
                content.classList.remove('expanded');
                content.classList.add('collapsed');
                icon.textContent = '‚ñ∂';
            }
        }
        
        // Input help panel functionality
        function toggleInputHelp() {
            const helpContent = document.getElementById('helpContent');
            helpContent.classList.toggle('active');
        }

        // Initialize
        updateButtons();
    </script>
</body>
</html>