<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Boundary Contact Sheet</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }

        .pagination {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
        }

        .pagination button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
        }

        .pagination button:hover {
            background: #f0f0f0;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination .current {
            background: #007AFF;
            color: white;
            border-color: #007AFF;
        }

        .info {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
        }

        .city-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .city-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .city-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .city-map {
            height: 200px;
            width: 100%;
            position: relative;
        }

        .city-info {
            padding: 15px;
            text-align: center;
            border-top: 1px solid #eee;
        }

        .city-name {
            font-weight: 600;
            color: #333;
            margin: 0 0 8px 0;
            font-size: 16px;
        }

        .city-meta {
            font-size: 14px;
            color: #666;
            margin: 0;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #fef2f2;
            color: #dc2626;
            padding: 15px;
            border-radius: 6px;
            margin: 10px 0;
            border: 1px solid #fecaca;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #007AFF;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Leaflet map styling for contact sheet */
        .leaflet-container {
            background: #f8f9fa;
        }
        
        .leaflet-control-container {
            display: none; /* Hide zoom controls for cleaner look */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è City Boundary Contact Sheet</h1>
        
        <div class="controls">
            <button onclick="location.reload()" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-weight: 600;">
                üîÑ Refresh Data
            </button>
        </div>
        
        <div class="controls">
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-number" id="totalCities">-</div>
                    <div class="stat-label">Total Cities</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="withBoundaries">-</div>
                    <div class="stat-label">With Boundaries</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="currentPage">1</div>
                    <div class="stat-label">Current Page</div>
                </div>
                <div class="stat-box">
                    <div class="stat-number" id="perPage">20</div>
                    <div class="stat-label">Per Page</div>
                </div>
            </div>
            
            <div class="pagination">
                <button id="firstBtn">First</button>
                <button id="prevBtn">Previous</button>
                <span id="pageInfo">Page 1 of 1</span>
                <button id="nextBtn">Next</button>
                <button id="lastBtn">Last</button>
            </div>
        </div>

        <div class="info" id="loadingInfo">Loading city data...</div>
        
        <div class="city-grid" id="cityGrid"></div>
        
        <div class="pagination">
            <button id="firstBtn2">First</button>
            <button id="prevBtn2">Previous</button>
            <span id="pageInfo2">Page 1 of 1</span>
            <button id="nextBtn2">Next</button>
            <button id="lastBtn2">Last</button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Configuration
        const CITIES_PER_PAGE = 20;
        let currentPage = 1;
        let totalPages = 1;
        let citiesWithBoundaries = [];
        let allCities = [];

        // Pagination state
        let isLoading = false;

        // Initialize the contact sheet
        async function init() {
            try {
                await loadCityData();
                await loadBoundaryData();
                sortCitiesBySize();
                setupPagination();
                renderCurrentPage();
            } catch (error) {
                console.error('Failed to initialize contact sheet:', error);
                document.getElementById('loadingInfo').innerHTML = 
                    `<div class="error">Failed to load city data: ${error.message}</div>`;
            }
        }

        // Load city database (with cache busting for fresh data)
        async function loadCityData() {
            const cacheBuster = Date.now();
            const response = await fetch(`cities-database.json?v=${cacheBuster}`);
            const data = await response.json();
            allCities = data.cities;
            
            document.getElementById('totalCities').textContent = allCities.length;
            document.getElementById('loadingInfo').textContent = 'Loading boundary files...';
        }

        // Load and process boundary data
        async function loadBoundaryData() {
            const cacheBuster = Date.now();
            const loadPromises = allCities.map(async (city) => {
                try {
                    const response = await fetch(`${city.id}.geojson?v=${cacheBuster}`);
                    if (response.ok) {
                        const geojson = await response.json();
                        const area = calculateGeoJSONArea(geojson);
                        return {
                            ...city,
                            geojson: geojson,
                            area: area,
                            hasBoundary: true
                        };
                    }
                } catch (error) {
                    // City doesn't have boundary file
                }
                return null;
            });

            const results = await Promise.all(loadPromises);
            citiesWithBoundaries = results.filter(city => city !== null);
            
            document.getElementById('withBoundaries').textContent = citiesWithBoundaries.length;
            document.getElementById('loadingInfo').textContent = 
                `Found ${citiesWithBoundaries.length} cities with boundary data`;
        }

        // Calculate approximate area of GeoJSON (rough calculation for sorting)
        function calculateGeoJSONArea(geojson) {
            let totalArea = 0;
            
            function processCoordinates(coords) {
                if (!coords || coords.length < 3) return 0;
                
                // Simple bounding box area calculation
                let minLat = Infinity, maxLat = -Infinity;
                let minLng = Infinity, maxLng = -Infinity;
                
                coords.forEach(coord => {
                    const [lng, lat] = coord;
                    minLat = Math.min(minLat, lat);
                    maxLat = Math.max(maxLat, lat);
                    minLng = Math.min(minLng, lng);
                    maxLng = Math.max(maxLng, lng);
                });
                
                return (maxLat - minLat) * (maxLng - minLng);
            }

            if (geojson.type === 'FeatureCollection') {
                geojson.features.forEach(feature => {
                    if (feature.geometry) {
                        if (feature.geometry.type === 'Polygon') {
                            totalArea += processCoordinates(feature.geometry.coordinates[0]);
                        } else if (feature.geometry.type === 'MultiPolygon') {
                            feature.geometry.coordinates.forEach(polygon => {
                                totalArea += processCoordinates(polygon[0]);
                            });
                        }
                    }
                });
            } else if (geojson.type === 'Feature') {
                if (geojson.geometry.type === 'Polygon') {
                    totalArea = processCoordinates(geojson.geometry.coordinates[0]);
                } else if (geojson.geometry.type === 'MultiPolygon') {
                    geojson.geometry.coordinates.forEach(polygon => {
                        totalArea += processCoordinates(polygon[0]);
                    });
                }
            }
            
            return totalArea;
        }

        // Sort cities by area (largest to smallest)
        function sortCitiesBySize() {
            citiesWithBoundaries.sort((a, b) => b.area - a.area);
            totalPages = Math.ceil(citiesWithBoundaries.length / CITIES_PER_PAGE);
        }

        // Setup pagination controls
        function setupPagination() {
            const buttons = ['firstBtn', 'prevBtn', 'nextBtn', 'lastBtn', 
                           'firstBtn2', 'prevBtn2', 'nextBtn2', 'lastBtn2'];
            
            buttons.forEach(btnId => {
                document.getElementById(btnId).addEventListener('click', () => {
                    const action = btnId.replace(/Btn\d?$/, '');
                    switch(action) {
                        case 'first': goToPage(1); break;
                        case 'prev': goToPage(Math.max(1, currentPage - 1)); break;
                        case 'next': goToPage(Math.min(totalPages, currentPage + 1)); break;
                        case 'last': goToPage(totalPages); break;
                    }
                });
            });
        }

        // Navigate to specific page
        function goToPage(page) {
            if (page < 1 || page > totalPages || page === currentPage || isLoading) return;
            
            currentPage = page;
            renderCurrentPage();
        }

        // Render current page of cities
        function renderCurrentPage() {
            if (isLoading) return;
            isLoading = true;

            const startIndex = (currentPage - 1) * CITIES_PER_PAGE;
            const endIndex = Math.min(startIndex + CITIES_PER_PAGE, citiesWithBoundaries.length);
            const pageData = citiesWithBoundaries.slice(startIndex, endIndex);

            // Update page info
            document.getElementById('currentPage').textContent = currentPage;
            document.getElementById('pageInfo').textContent = `Page ${currentPage} of ${totalPages}`;
            document.getElementById('pageInfo2').textContent = `Page ${currentPage} of ${totalPages}`;

            // Update pagination buttons
            updatePaginationButtons();

            // Clear grid and render cards
            const grid = document.getElementById('cityGrid');
            grid.innerHTML = '';

            pageData.forEach((city, index) => {
                const card = createCityCard(city, startIndex + index + 1);
                grid.appendChild(card);
            });

            // Initialize maps after DOM update
            setTimeout(() => {
                pageData.forEach((city, index) => {
                    initializeCityMap(city, startIndex + index + 1);
                });
                isLoading = false;
            }, 100);

            document.getElementById('loadingInfo').textContent = 
                `Showing cities ${startIndex + 1}-${endIndex} of ${citiesWithBoundaries.length} (sorted by size)`;
        }

        // Update pagination button states
        function updatePaginationButtons() {
            const buttons = {
                first: ['firstBtn', 'firstBtn2'],
                prev: ['prevBtn', 'prevBtn2'], 
                next: ['nextBtn', 'nextBtn2'],
                last: ['lastBtn', 'lastBtn2']
            };

            buttons.first.concat(buttons.prev).forEach(btnId => {
                document.getElementById(btnId).disabled = currentPage === 1;
            });

            buttons.next.concat(buttons.last).forEach(btnId => {
                document.getElementById(btnId).disabled = currentPage === totalPages;
            });
        }

        // Create city card HTML
        function createCityCard(city, rank) {
            const card = document.createElement('div');
            card.className = 'city-card';
            card.innerHTML = `
                <div class="city-map" id="map-${city.id}"></div>
                <div class="city-info">
                    <h3 class="city-name">${city.name}</h3>
                    <p class="city-meta">#${rank} ‚Ä¢ ${city.country}</p>
                </div>
            `;
            return card;
        }

        // Initialize Leaflet map for a city
        function initializeCityMap(city, rank) {
            const mapId = `map-${city.id}`;
            const mapElement = document.getElementById(mapId);
            
            if (!mapElement || !city.geojson) return;

            try {
                // Calculate bounds for the city
                const bounds = L.geoJSON(city.geojson).getBounds();
                
                // Create map
                const map = L.map(mapId, {
                    zoomControl: false,
                    scrollWheelZoom: false,
                    doubleClickZoom: false,
                    boxZoom: false,
                    keyboard: false,
                    dragging: false,
                    touchZoom: false
                });

                // Add tile layer
                L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
                    maxZoom: 19,
                    attribution: ''
                }).addTo(map);

                // Add boundary
                L.geoJSON(city.geojson, {
                    style: {
                        color: '#007AFF',
                        weight: 2,
                        opacity: 0.8,
                        fillColor: '#007AFF',
                        fillOpacity: 0.2
                    }
                }).addTo(map);

                // Fit bounds with padding
                map.fitBounds(bounds, { padding: [10, 10] });

            } catch (error) {
                console.error(`Failed to render map for ${city.name}:`, error);
                mapElement.innerHTML = `<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #999;">Map Error</div>`;
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>